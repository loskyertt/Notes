# 1.基本概念

对于指针，指针（`T*`）本质上是一个变量，**里面存放的是另一块内存的地址**，那块内存里放着一个（或多个）`T` 类型对象。同样，完全可以把指针当成一个**整型的数据**（比如：`0x7ffd94cd9564`，这是一个整型数据，但表示的是内存块的地址）。

- **两大操作符**
    
    - 取地址：`&obj` 得到 `obj` 的地址（类型是 `T*`）。
        
    - 解引用：`*p` 访问指针 `p` 所指向的对象本身（类型是 `T&`）。

```cpp
int x = 42;
int* p = &x;    // p 里装的是 x 的地址
*p = 7;         // 通过 p 改 x，x 变成 7
```

假设 `x` 的地址是 `0x10a3`，那么 `p` 这个变量装的内容就是 `0x10a3`（即指向的就是一块内存地址），当用 `*p` 时，实际上就是**取 `0x10a3` 这个地址的值**。

---

# 2.指针 vs 引用

- **引用**是已有对象的**别名**，不能为 `null`（语义上），一旦绑定就**不可改指向**。
    
- **指针**可以为空（`nullptr`）、可以指向不同对象、可以做算术（数组场景）。
    
- **指针的引用** = “**指针变量本身**的别名”。

```cpp
void f(int *&rp) {         // rp 是“指向 int 的指针”的引用
    static int y = 99;
    rp = &y;               // 这会修改调用方的指针变量本身
}

int x = 1;
int* p = &x;
f(p);                      // p 现在指向 y 了
```

---

# 3.存储期与所有权

理解“对象活多久”和“谁负责释放”是用好指针的关键。

- **自动存储（栈）**：局部变量，离开作用域自动销毁。
    
- **静态存储**：程序期内一直存在（`static`、全局）。
    
- **动态存储（堆）**：`new` 分配，**你负责**用 `delete`、`delete[]` 释放。

创建一个指针 root，让 root 指向内存中存放 2 这个数字的地址：

```cpp
TreeNode* root = new TreeNode(2); // 在堆上
```

像这样：

```
栈 (stack)         堆 (heap)
----------         -------------
root ────────────▶ [ TreeNode(2) ]
```

删除内存中存放 2 这个数字的地址的数据：

```cpp
delete root;                      // 释放堆内存（root 变量本身还在）
root = nullptr;                   // 防止悬空
```

像这样：

```
栈 (stack)         堆 (heap)
----------         -------------
root ────────────▶ [   已释放   ]
```

> 关键点：`delete root;` **释放的是 root 指向的对象**（在这里，root 指向的就是存放 2 这个数的节点的地址），不是把 `root` 这个变量“删掉”。`root` 仍然存在，但变成悬空指针，所以要把它设为 `nullptr`。

一颗小树的内存示意图😀：

```cpp
// 内存布局示意图（假设地址从0x1000开始）

// TreeNode结构定义（假设）:
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 创建节点后的内存状态:
TreeNode* root = new TreeNode(8);    // 地址: 0x1000
root->left = new TreeNode(4);        // 地址: 0x2000  
root->right = new TreeNode(12);      // 地址: 0x3000

/*
内存布局:

栈内存:
+-----------+----------+
| 变量名    | 值       |
+-----------+----------+
| root      | 0x1000   |
+-----------+----------+

堆内存:
地址 0x1000 (root 指向的地址):
+----------+----------+----------+
| val: 8   | left:0x2000 | right:0x3000 |
+----------+----------+----------+

地址 0x2000 (root->left 指向的地址):
+----------+----------+----------+
| val: 4   | left:nullptr | right:nullptr |
+----------+----------+----------+

地址 0x3000 (root->right 指向的地址):
+----------+----------+----------+
| val: 12  | left:nullptr | right:nullptr |
+----------+----------+----------+
*/

// 树形结构:
//       8
//      / \
//     4   12
```

---

# 4.常见指针的“坑”

- **未初始化指针（野指针）**：`int* p; *p = 1;` —— 未定义行为。
    
- **空指针解引用**：`int* p = nullptr; *p = 1;` —— 未定义行为。
    
- **悬空指针（use-after-free）**：`delete p; *p = 1;` —— 未定义行为。
    
- **双重释放**：同一块内存 `delete` 两次 —— 未定义行为。
    
- **数组释放方式错误**：`new[]` 必须 `delete[]`；单对象 `new` 必须 `delete`。
    
- **多态删除没虚析构**：通过**基类指针**删除派生对象，基类析构必须 `virtual`，否则派生析构不会被调用，资源泄漏。

## 4.1 指针传参和指针引用传参

看如下示例：

```cpp
#include <iostream>

void test01(int *&p) {
  delete p;
  p = nullptr; // 这里相当于把 main 函数中的 ptr1 置空
}

void test02(int *p) {
  delete p;
  p = nullptr; // 这里只是把 main 函数中的 ptr2 的副本（即 p）置空
}

/* 经典指针问题 */
int main() {

  int *ptr1 = new int(10);

  std::cout << "ptr1 = " << *ptr1 << "\n";
  std::cout << "ptr1 指向的地址：" << ptr1 << "\n";

  test01(ptr1);

  if (ptr1 == nullptr) {
    std::cout << "ptr1 指针指向为空！\n";
  }
  std::cout << "ptr1 指向的地址：" << ptr1 << "\n";

  std::cout << "\n";

  int *ptr2 = new int(2);

  std::cout << "ptr2 = " << *ptr2 << "\n";
  std::cout << "ptr2 指向的地址：" << ptr2 << "\n";

  test02(ptr2);

  if (ptr2 == nullptr) {
    std::cout << "ptr2 指针指向为空！\n";
  } else {
    std::cout << "ptr2 指针指向未知内存地址！\n";
    std::cout << "ptr2（野指针） = " << *ptr2 << "\n";
  }

  std::cout << "ptr2 指向的地址：" << ptr2 << "\n";

}
```

1. 对于 `test01(int *&p)`：

这里参数是 **指针的引用**，也就是调用者那个指针变量的别名。所以 `delete p; p = nullptr;` 实际上等价于：
    
```cpp
delete ptr1;
ptr1 = nullptr;
```
    
调用完后，**主函数里的 `ptr1` 被置空了**。✅ **调用者安全，不会产生野指针。**

2. 对于 `test02(int *p)`：

这里参数是 **指针的拷贝**。`delete p;` 会释放掉堆里的那块内存（`new int(2)`），但 `p = nullptr;` 只改变了函数内部这份拷贝，不会影响主函数里的 `ptr2`。所以函数返回后：堆里的内存被释放，但是 `ptr2` 依旧保存着“刚刚那块已经释放的内存地址”。这就是**悬空指针（dangling pointer）**。实际等价于这样：

```cpp
int* p = ptr2;    // 把 ptr2 的值（存的地址），赋值给 p
delete p;
p = nullptr;
```

`p` 和 `ptr2` 实际上是两个不同的指针，但是都指向同一块内存地址，所以你把 `p` 置空，关我 `ptr2` 什么关系？这一步就是**未定义行为**，可能打印奇怪的数，也可能直接崩溃。

连续两次（或多次）的输出结果：

```bash
# 第一次输出结果
❯ ./build/test/error_test02                                                                                                      ─╯
ptr1 = 10
ptr1 指向的地址：0x5f09de7082b0
ptr1 指针指向为空！
ptr1 指向的地址：0

ptr2 = 2
ptr2 指向的地址：0x5f09de7082b0
ptr2 指针指向未知内存地址！
ptr2（野指针） = -258087160      <------- 看这里，这是“垃圾值”
ptr2 指向的地址：0x5f09de7082b0

# 第二次输出结果
❯ ./build/test/error_test02                                                                                                      ─╯
ptr1 = 10
ptr1 指向的地址：0x5932b81102b0
ptr1 指针指向为空！
ptr1 指向的地址：0

ptr2 = 2
ptr2 指向的地址：0x5932b81102b0
ptr2 指针指向未知内存地址！
ptr2（野指针） = -1825865456      <------- 看这里，这是“垃圾值”
ptr2 指向的地址：0x5932b81102b0
```

如果你注意力惊人的话，会发现 `ptr1` 和 `ptr2` 刚好分配到了相同的内存地址！`ptr1` 和 `ptr2` 之所以指向相同的地址，是因为 **堆内存分配器会重用刚释放的内存块**（`ptr1` 指向的内存块被释放过了）。这完全是正常的，也是 C++ 内存管理的常见现象。所以它们虽然看起来“住在同一个地址”，但这是 **两次不同的对象生命周期**。

---

# 5.指针的其它要点

## 5.1 const 与指针组合

- `const int* p`：**指向常量的指针**（不能通过 `p` 改所指对象；p 自己能改指向）
    
- `int* const p`：**常量指针**（p 不能改指向；但能改所指对象）
    
- `const int* const p`：两者都不能改

```cpp
int a=1, b=2;
const int* p = &a;   // *p 只读，p 可改
p = &b;              // OK

int* const q = &a;   // q 不可改指向，*q 可改
*q = 3;              // OK
```


## 5.2 指针与数组

- 数组名在大多数表达式里会**衰变**为指向首元素的指针（`T*`）。
    
- 指针可以做**指针算术**：`p+1` 指向下一个元素（步长按 `sizeof(T)`）。
    
- `sizeof(arr)` 与 `sizeof(p)` 不同：前者是数组大小（字节数），后者是指针大小。

```cpp
int arr[3] = {1,2,3};
int* p = arr;      // 等价于 &arr[0]
*(p+1) = 42;       // 改 arr[1]
```

> 注意：`std::vector` 增长会搬家，**保存它元素的指针/引用会失效**。


## 5.3 函数参数传递的几种方式

- `T* p`：传入一个地址的**拷贝**；你改 `p` 的指向，**调用方看不见**。
    
- `T*& p`：传入“指针本身的引用”；你改 `p` 的指向，**调用方同步改变**（BST 删除用的就是它）。
    
- `T& x`：传入对象别名；不能为 null，不能改引用的绑定对象。


## 5.4 其他指针类型（知道即可）

- **`void*`**：无类型指针，只能存地址，不能直接解引用；需要强转回原类型。
    
- **成员指针**：`int C::* pm;` / `int (C::*pf)(...)`。调用语法特殊：`(obj.*pf)()`、`(ptr->*pm)`。
    
- **指向函数的指针**：`int (*fp)(int);`；现代 C++ 更推荐用 `auto`、`std::function`、lambda。
    
- **类型转换**：
    
    - `static_cast`：编译期安全、常用；
        
    - `reinterpret_cast`：位级别重解释，危险；
        
    - `const_cast`：加/去 const；
        
    - `dynamic_cast`：多态向下转型，需多态基类（有虚函数），失败返回 `nullptr`（指针场景）。
        