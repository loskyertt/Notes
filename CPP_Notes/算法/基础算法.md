# 1.二分查找

二分查找算法中，如果使用闭区间方式（即 `i = 0, j = nums.size() - 1`），若 `target` 不在数组中，循环结束时 `i` 和 `j` 的关系为 $i = j + 1$（即 `i` 在 `j` 的右边）。此时：
- `i` 指向的是**第一个大于等于 `target` 的元素**的位置（如果存在这样的元素，否则 `i` 会等于 `nums.size()`）。
- `j` 指向的是**最后一个小于 `target` 的元素**的位置（如果存在这样的元素，否则 `j` 会等于 `-1`）。

> 这个性质在需要插入 `target` 到有序数组时非常有用（即 `i` 就是插入位置）。

二分查找的闭区间实现通常如下：

```cpp
int binarySearch(const std::vector<int>& nums, int target) {
    int i = 0, j = nums.size() - 1;  // 闭区间：[i, j]
    while (i <= j) {
        int mid = i + (j - i) / 2;   // 用 (i+j)/2 可能导致溢出
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            i = mid + 1;
        } else {
            j = mid - 1;
        }
    }
    return -1; // 未找到
}
```

举例说明：假设数组 `nums = [1, 3, 5, 7]`，查找不同的 `target`。

1. `target = 0`（小于所有元素）：
   - 循环结束时 `i = 0`, `j = -1`。
   - `i` 指向第一个大于等于 0 的元素（即 1）的位置（索引 0）。

2. `target = 2`（介于 1 和 3 之间）：
   - 循环结束时 `i = 1`, `j = 0`。
   - `i` 指向第一个大于等于 2 的元素（即 3）的位置（索引 1）。

3. `target = 4`（介于 3 和 5 之间）：
   - 循环结束时 `i = 2`, `j = 1`。
   - `i` 指向第一个大于等于 4 的元素（即 5）的位置（索引 2）。

4. `target = 8`（大于所有元素）：
   - 循环结束时 `i = 4`, `j = 3`。
   - `i` 指向 `nums.size()`（即 4），因为不存在大于等于 8 的元素。

---

# 2.快慢指针

## 2.1 查找链表中点

示例：

```cpp
ListNode *find_middle(ListNode* head){
    ListNode *slow = head, *fast = head;
	
    while(fast && fast->next){
        fast = fast->next->next;
        slow = slow-next
    }

    return slow;
}
```

如这段代码所示，设置快慢指针，让 `fast` 节点走的步数是 `slow` 节点走的步数的两倍。

循环结束后，`slow` 的指向：
- 节点数为奇数：`slow` 正好指向链表中点。
- 节点数为偶数：`slow` 指向后半部分的第一个节点。

这里的 `fast && fast->next` 这是标准的快慢指针写法，适用于链表长度为 **偶数或奇数** 的情况（比如：若 `fast` 能到链表最后一个节点，那么执行`fast->next->next` 就会报错，因为 `fast->next` 此时就是 `nullptr`）。

> 快慢指针除了应用与找链表的中间节点，还可以求解”获取倒数第 `k` 个节点这种问题“，思考一下怎么通过快慢指针求解。

## 2.2 删除数组中元素

下面介绍一种经典的**双指针技巧**，是一种高效的原址删除算法。

```cpp
void remove_target(std::vector<int> &nums, int target){
	int i = 0;
	
	for(int j = 0; j < nums.size(); ++j){
		if(nums[j] != target){
			nums[i] = nums[j];
			++i;
		}
	}
	
	nums.resize(i);
}
```

**双指针角色：**

- **`i` 指针（慢指针）**：指向下一个应该存放**保留元素**的位置，循环结束后，**`i` 的值 = 有效元素个数 = 新数组长度**。
    
- **`j` 指针（快指针）**：遍历整个数组，检查每个元素。

当 `nums[j] == target` 时（第一次），`i` 指针就会指向 `target` 元素的位置，下次循环的时候会用下一个值 `nums[j]` 覆盖掉 `nums[i]`，再次循环的时候，会把数组中的元素往前移（因为 `i` 落后与 `j`）。

可视化实例，删除数组中的元素 `3`：

```
步骤   i   j  nums[j]  操作          数组状态
初始   0   0    3      跳过        [3,5,3,2,9,10,3,4]
1      0   1    5      复制→i=0    [5,5,3,2,9,10,3,4] → i=1
2      1   2    3      跳过        [5,5,3,2,9,10,3,4]
3      1   3    2      复制→i=1    [5,2,3,2,9,10,3,4] → i=2  
4      2   4    9      复制→i=2    [5,2,9,2,9,10,3,4] → i=3
5      3   5    10     复制→i=3    [5,2,9,10,9,10,3,4] → i=4
6      4   6    3      跳过        [5,2,9,10,9,10,3,4]
7      4   7    4      复制→i=4    [5,2,9,10,4,10,3,4] → i=5

最终：i = 5（有效元素个数）
```

---

# 2.Boyer-Moore 投票算法

这是一个很经典的算法，用于查找数组中出现次数超过一半的“主元素”（majority element）。

## 2.1 算法思路

1. 核心思想：**抵消法**
	- 主元素出现次数 > `n/2`。
	- 所以我们可以假设：**每个非主元素都会“抵消”一个主元素**。
	- 但如果主元素真的存在，它最终不会被完全抵消。

> 这个算法的关键在于：**只有当主元素存在时，这个“幸存者”才是主元素。否则幸存者可能是任意值。**所以必须进行第二遍验证！

2. 时间 & 空间复杂度

| 项目 | 复杂度 | 说明 |
|------|--------|------|
| 时间复杂度 | O(n) | 两遍遍历 |
| 空间复杂度 | O(1) | 只用常数额外空间 |

## 2.2 代码

```cpp
int boyerMoore(const std::vector<int> &nums) {
    if (nums.empty()) {
        return -1;
    }

    int count = 0;
    int candidate_num = 0;

    // 投票阶段
    for (int val : nums) {
        if (count == 0) {
            candidate_num = val;
        }
        count += (val == candidate_num) ? 1 : -1;
    }

    // 验证阶段
    count = 0;
    for (int val : nums) {
        if (val == candidate_num) {
            count++;
        }
    }

    return (count > nums.size() / 2) ? candidate_num : -1;
}
```

1. **第一遍扫描（投票阶段）**  
   - 维护一个候选值 `candidate_num` 和计数器 `count`。
   - 遇到相同值就 `count++`，不同就 `count--`。
   - 如果 `count == 0`，就换当前元素为新的候选。
   - 这个过程的原理是：**主元素的数量超过一半，所以它能“抵消”所有其他元素后仍然存活。**

2. **第二遍扫描（验证阶段）**  
   - 重新统计 `candidate_num` 的实际出现次数。
   - 判断是否真的超过 `n/2`，防止不存在主元素时误判。

3. **返回结果**  
   - 如果确实超过一半，返回该数；否则返回 `-1`。

---

# 3.计数排序法

## 3.1 算法思路

这个算法仍然可以用于寻找数组中占比超过一半的元素（主元素）。基于**计数排序思想**，具体思路如下：

1. **确定值域范围**：  
    先找出数组中的最大值 `max_val` 和最小值 `min_val`，计算值域大小 `n = max_val - min_val + 1`，用于创建计数数组。
    
2. **构建计数数组**：  
    创建大小为 `n` 的数组 `count`，初始化为 0。  
    遍历原数组，对每个元素 `num`，将其映射到下标 `num - min_val`，并对 `count[num - min_val]` 进行自增，实现频次统计。
    
3. **查找主元素**：  
    再次遍历 `count` 数组，若某个位置 `i` 的计数值 `count[i] > nums.size() / 2`，则对应的原始元素为 `i + min_val`，即为主元素，直接返回。  
    若遍历结束未找到，则返回 -1。
    
该方法时间复杂度为 `O(n)`，但空间复杂度为 `O(值域范围)`，适用于值域较小的场景。

## 3.2 代码

下面实现的这种算法也可以叫做“原地哈希”。

```cpp
int count_sort(const vector<int> &nums){
    if (nums.empty()) return -1;

	// 找出元素范围
	int max_val = *max_element(nums.begin(), nums.end());
	int min_val = *min_element(nums.begin(), nums.end());
	int n = max_val - min_val + 1;
	
	vector<int> count(n, 0);   // 计数使用
	
	for(const int &num : nums){
		++count[num - min_val];
	}
	
    int threshold = nums.size() / 2;
    for (int i = 0; i < n; ++i) {
		// 如果计数超过一半，说明找到目标元素
        if (count[i] > threshold) {
            return i + min_val;
        }
    }
	
	return -1;  // 表示没找到
}
```

当然，也可以直接用哈希表 `unordered_map` 来代替 `vector`，就可以适用于值域比较大的场景：

```cpp
int hash_majority(const vector<int>& nums) {
    if (nums.empty()) return -1;
    
    unordered_map<int, int> count;
    
    int threshold = nums.size() / 2;
    for (int num : nums) {
        if (++count[num] > threshold) {
            return num;
        }
    }
    return -1;
}
```

对于 `++count[num] > threshold` 这部分，如果 `num` 第一次出现，`count` 中没有这个键，C++ 会**自动插入 `num`，并将其值初始化为 0**（这是 `std::unordered_map` 的默认行为）。

这种边遍历边判断有一个好处：因为只要某个元素的计数**一旦超过 `n/2`**，它就一定是主元素（出现次数超过一半），可以直接返回，**不需要遍历完**。

---

# 4.三数组最小曼哈顿距离

“三数组最小曼哈顿距离”也被称为“三元组最短距离”。

## 4.1 问题定义和解析

给定三个**递增排序的数组** `A`, `B`, `C`，从每个数组中各选一个数构成三元组 `(a, b, c)`，定义其**距离**为：

$$
\text{dist} = |a - b| + |b - c| + |c - a|
$$

目标：**找出所有可能三元组中距离最小的一个**。

注意我们定义的距离：

$$
|a - b| + |b - c| + |c - a|
$$

这个表达式其实可以**化简**，对于任意三个实数 $a, b, c$，有恒等式：

$$
|a - b| + |b - c| + |c - a| = 2 \times (\max(a,b,c) - \min(a,b,c))
$$

✅ **证明思路**：

假设 $a \leq b \leq c$，则：
- $|a-b| = b - a$
- $|b-c| = c - b$
- $|c-a| = c - a$
- 总和：$(b - a) + (c - b) + (c - a) = 2c - 2a = 2(c - a)$

所以：
$$
\text{dist} = 2 \times (\text{max} - \text{min})
$$

## 4.2 思路：三指针 + 贪心移动

> **要最小化三元组的距离，应该让三个数尽可能“靠近”**。

我们可以使用 **三指针法（Three Pointers）**，从每个数组的开头开始，每次移动指向**当前最小值**的那个指针。

为什么呢？

- 因为最大距离通常由最大值和最小值决定
- 当前最小值如果不增大，其他值再大也只会让距离更大
- 所以我们应该尝试**增大最小值**，使三数更接近

## 4.3 代码

```cpp
int get_min_dist(const std::vector<int> &A, const std::vector<int> &B, const std::vector<int> &C){
	int min_dist = INT_MAX;
	
	// 定义分别指向 A B C 中元素的指针
	int i = 0, j = 0, k = 0;
	while(i < A.size() && j < B.size() && k < C.size()){
		int a = A[i], b = B[j], C = C[k];
		
		// 计算当前三元组的距离
		int min_val = std::min({a, b, c});
		int max_val = std::max({a, b, c});
		
		int dist = 2 * (max_val - min_val);
		min_dist = std::min(dist, min_dist);
		
		// 移动指向最小值的指针
		if(a == min_val){
			++i;
		}
		else if(b == min_val){
			++j;
		}
		else{
			++k;
		}
	}

	return min_dist;
}
```

- 每次移动最小值的指针，是在尝试“拉近”三个数
- 因为数组有序，不移动最小值只会让差距更大
- 虽然不能证明**一定不会错过最优解**，但在这种对称距离函数下，该贪心策略是正确的（可通过反证法证明）

> 注意：这个贪心策略依赖于距离函数的性质。如果是其他距离（如欧氏距离），可能不适用。

---

# 5.树

## 5.1 判断是否是BST

### 5.1.1 顺序存储

```cpp
#include <climits>
#include <vector>
using namespace std;

bool isBSTHelper(const vector<int>& tree, int index, long long minVal, long long maxVal) {
    if (index >= tree.size() || tree[index] == -1) {
        return true; // 空节点合法
    }

    int val = tree[index];
    if (val <= minVal || val >= maxVal) {
        return false; // 超出允许范围
    }

    // 检查左右子树
    int left = 2 * index + 1;
    int right = 2 * index + 2;

    return isBSTHelper(tree, left, minVal, val) && 
           isBSTHelper(tree, right, val, maxVal);
}

bool is_BST(vector<int> tree) {
    return isBSTHelper(tree, 0, LLONG_MIN, LLONG_MAX);
}
```


### 5.1.2 链式存储

树的定义：

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

代码实现：

方式一：递归 + 值域约束

```cpp
bool isValidBST(TreeNode* root) {
    return validate(root, LLONG_MIN, LLONG_MAX);
}

bool validate(TreeNode* node, long long min_val, long long max_val) {
    if (!node) return true;
    
    // 检查当前节点是否在合法范围内
    if (node->val <= min_val || node->val >= max_val) 
        return false;
    
    // 递归检查左右子树
    return validate(node->left, min_val, node->val) && 
           validate(node->right, node->val, max_val);
}
```

方式二：递归 + 中序遍历 + 单调递增

```cpp
bool isValidBST(TreeNode* root) {
    TreeNode* prev = nullptr;
    return inorder(root, prev);
}

bool inorder(TreeNode* node, TreeNode*& prev) {
    if (!node) return true;
    
    if (!inorder(node->left, prev)) 
        return false;
    
    if (prev && prev->val >= node->val) 
        return false;
    
    prev = node;
    return inorder(node->right, prev);
}
```

方式三：迭代 + 中序遍历 + 单调递增

```cpp
bool isValidBST(TreeNode* root) {
    stack<TreeNode*> stk;
    TreeNode* prev = nullptr;
    TreeNode* curr = root;
    
    while (curr || !stk.empty()) {
        while (curr) {
            stk.push(curr);
            curr = curr->left;
        }
        curr = stk.top(); stk.pop();
        
        if (prev && prev->val >= curr->val) 
            return false;
        
        prev = curr;
        curr = curr->right;
    }
    return true;
}
```

## 5.2 判断二叉树是否对称

方式一：递归实现

```cpp
bool isSymmetric(TreeNode* root) {
    if (!root) return true; // 空树视为对称
    return isMirror(root->left, root->right);
}

bool isMirror(TreeNode* left, TreeNode* right) {
    // 两者都为空 → 对称
    if (!left && !right) return true;
    
    // 一个为空，另一个非空 → 不对称
    if (!left || !right) return false;
    
    // 值不等 → 不对称
    if (left->val != right->val) return false;
    
    // 递归检查：左的左 vs 右的右，左的右 vs 右的左
    return isMirror(left->left, right->right) && 
           isMirror(left->right, right->left);
}
```

方式二：迭代实现

```cpp
#include <queue>

bool isSymmetric(TreeNode* root) {
    if (!root) return true;
    
    std::queue<TreeNode*> q;
    q.push(root->left);
    q.push(root->right);
    
    while (!q.empty()) {
        TreeNode* left = q.front(); q.pop();
        TreeNode* right = q.front(); q.pop();
        
        if (!left && !right) continue;           // 两空，跳过
        if (!left || !right) return false;       // 一空一非空
        if (left->val != right->val) return false; // 值不等
        
        // 按镜像顺序入队：左左 & 右右，左右 & 右左
        q.push(left->left);
        q.push(right->right);
        q.push(left->right);
        q.push(right->left);
    }
    
    return true;
}
```

## 5.3 判断是否是平衡二叉树

```cpp
#include <algorithm>
#include <cmath>

// 假设二叉树结点定义如下
struct BTree {
    int data;
    BTree *left, *right;
};

/**
 * @brief 获取树的高度，并同时判断是否平衡
 * @return 如果平衡返回树的实际高度，否则返回 -1
 */
int getHeight(BTree* root) {
    if (root == nullptr) {
        return 0; // 空树高度为 0，且是平衡的
    }

    // 递归获取左子树高度
    int leftHeight = getHeight(root->left);
    if (leftHeight == -1) return -1; // 左子树已不平衡，提前返回

    // 递归获取右子树高度
    int rightHeight = getHeight(root->right);
    if (rightHeight == -1) return -1; // 右子树已不平衡，提前返回

    // 检查当前节点是否平衡
    if (std::abs(leftHeight - rightHeight) > 1) {
        return -1; // 当前节点高度差 > 1，标记为不平衡
    }

    // 若平衡，返回当前节点的高度
    return std::max(leftHeight, rightHeight) + 1;
}

/**
 * @brief 判断一棵树是否为平衡二叉树
 * @param root 根结点指针
 * @return 若平衡返回 1 (true)，否则返回 0 (false)
 */
int isBalanced(BTree* root) {
    return getHeight(root) != -1;
}
```