---
title: 栈、队列和数组
date: 2025-03-07 20:58:41
tags:
    - "cpp"
excerpt: "(*/ω＼*)"
categories: "数据结构"
---

# 1.栈

卡特兰数公式：当 n 个不同元素入栈时，出栈元素不同排列的个数为：
$$
\frac{1}{n+1} C_{2n}^{n}
$$

---

# 2.队列

## 2.1 循环队列

当用数组实现循环队列时（`front` 为队首索引，`rear` 为队尾索引，`maxSize` 是队列容量）：

1. **队空** 条件：`front == rear`

```
数组：[_, _, _, _]
      ↑
     front, rear
```

2. **队满** 条件：`(rear + 1) % maxSize == front`

```
数组：[1, 2, 3, 4, _]
       ↑           ↑
     front        rear
```

这里 `rear` 指向索引 4 的位置，`front` 指向索引 `0` 的位置，`maxSize = 5`（数组容量），此时 `(4 + 1) % 5 == 0` 成立，故表示为空。

综上，队列已满的条件：队尾指针的再下一个位置是队头。

> 为什么要留最后一个位置为空呢？
> 如果不留最后一个空位置，那么就直接变成了 `front == rear` 了，就会与判空的条件矛盾。

注意：一般情况下，循环队列队满时，少用一个空间，也就是说，**`rear` 指向的位置始终是空的**！（除非题目刻意说明，`rear` 指向的是**队尾元素**）。

3. 当进行出队操作后：`front = (front + 1) % maxSize`

```
出队前：
数组：[A, B, C, _, _]
       ↑     ↑
     front  rear

出队 A 后：
front = (0 + 1) % 5 = 1
数组：[_, B, C, _, _]
          ↑  ↑
        front rear
```

- 计算队列长度（队列中元素个数）：
$$
\text{queueSize} = (\text{rear} - \text{front} + \text{maxSize}) \% \text{maxSize}
$$

因为 `rear` 和 `front` 是循环的，不能直接 `rear - front`（可能为负数），所以加 `maxSize` 再取模保证非负。

---

# 3.数组

`LOC(a[0])` 表示数组索引为 `0` 处（第一个位置）的地址，`l` 是每个数组元素所占的存储单元大小。`i` 和 `j` 对应数组索引。

1. 一维数组存储地址计算：`LOC(a[i]) = LOC(a[start]) + (i - start) * l`，其中 `start` 为起始数组的地址或者索引。
2. 二维数组存储地址计算：
	- 行优先：`LOC(a[i][j]) = LOC(a[0][0]) + i*n*l + j*l`，`n` 为整个一行的元素个数。
	- 列优先：`LOC(a[i][j]) = LOC(a[0][0]) + j*m*l + i*l`，`m` 为整个一列的元素个数。

> 注意：用上面的计算地址公式，必须是起始索引为 `0` 才能直接使用！

3. **多维数组**：二维以上的数组。`n` 维数组是数组元素为 `n-1` 维数组的一维数组。

4. **压缩存储**：行优先存储上三角矩阵，列优先存储下三角矩阵。

5. **三对角矩阵**：只存储主对角线及以其上、下两侧对角线上的元素。比如下面是 `5*5` 的三对角矩阵：

```bash
| a  b  0  0  0 |
| c  d  e  0  0 |
| 0  f  g  h  0 |
| 0  0  i  j  k |
| 0  0  0  l  m |
```

6. **稀疏矩阵的压缩存储方式：**
	- 顺序存储表示：三元组顺序表（只存储非零元素）==> `(行下标, 列下标, 值)`。
	- 链式存储表示：简单的链式存储、行链存储、正交链存储。

---

# 4.广义表

表头：广义表的第一个元素。
表尾：广义表中 **除表头外其他元素组成的表** 。表尾不是最后一个元素！而是一个子表。
深度：广义表中括号的重数。