# 1.同步与互斥的概念

## 1.1 基本概念

1. **异步性**：即各并发执行的进程以不可预知的速度向前推进。
2. **同步性**：多个进程以一定的顺序来执行。同步亦称 **直接制约关系** ，它是指完成某种任务而建立的两个或多个进程因为需要在某些位置上 **协调** 它们的 **工作次序** 而产生的制约关系。

3. **互斥（资源共享方式）**：互斥亦称 **间接制约关系** 。
    - 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内 **只允许一个** 进程访问该资源。
    - 同时共享方式：系统中的某些资源，运行一个时间段内由 **多个进程“同时”** 对它们进行访问。

4. **临界资源**：一个时间段内只允许一个进程使用的资源。如：物理设备（摄像头、打印机）都属于临界资源，此外还有许多变量、数据、内存缓冲区都属于临界资源。因此对临界资源的访问，必须 **互斥** 地进行。
5. **临界区**：指进程中 **访问临界资源的那一段代码**。这段代码必须互斥执行，即在任一时刻，最多只能有一个进程在临界区中执行。

> 注意：临界区是指**进程的临界区**，进程通过**执行它（说明临界区是一段代码、指令）**来访问临界资源，即处于进程的代码段中！

对临界资源的互斥访问，可以逻辑上分为四个部分：

```C
do {
    /**
     * 进入区
     * 负责检查是否可以进入临界区
     * 若可以进入，则应设置正在访问临界资源的标志(上锁)
     * 以阻止其它进程同时访问临界区
     */
    entry section;
    
    /**
     * 临界区
     * 访问临界资源的代码
     */
    critical section;
    
    /**
     * 退出区
     * 负责解除正在访问临界资源的标志(解锁)
     */
    exit section;
    
    /**
     * 剩余区
     * 做其它处理
     */   
    remainder section;
} while (true)
```

## 1.2 互斥访问资源的原则

实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循下面四个原则：

1. **空闲让进：** 当临界区**空闲**，且有进程想进入时，**应能选出一个进程进入**，不能无故阻塞所有进程。
2. **忙则等待：** 如果临界区已经被占用（或即将被占用），其他进程必须等待，不能强行进入。
3. **有限等待：** 一个进程请求进入临界区后，**等待的时间是有限的**，不能无限期等待。
4. **让权等待：** 当一个进程在等待进入临界区时，**应当释放 CPU**，进入阻塞状态，让其他进程使用 CPU，而不是“忙等”（busy waiting）。

---

# 2.互斥的实现方式

## 2.1 互斥的软件实现方式

### 2.1.1 单标志法

算法思想：两个进程在访问临界区后会把使用临界区的权限转交给另一个进程。也就是说 **每个进程进入临界区的权限只能被另一个进程赋予** 。

```C
int turn = 0; // turn 表示当前允许进入临界区的进程号(表示谦让)，初始允许 P0 进入

// P0 进程
while (turn != 0);        // 等待 turn == 0
critical_section();       // 临界区
turn = 1;                 // 谦让：把使用权交给 P1
remainder_section();      // 剩余区

// P1 进程
while (turn != 1);        // 等待 turn == 1
critical_section();       // 临界区
turn = 0;                 // 谦让：把使用权交给 P0
remainder_section();      // 剩余区
```

场景模拟：P0 只运行一次，P1 想多次进入临界区

- 初始：`turn = 0`
- **P0 先运行**：
  - `while(turn != 0)` → 条件不成立，进入临界区。
  - 执行完临界区后，执行 `turn = 1`，表示“我把权利让给 P1”。
  - 然后进入 `remainder_section()`，之后可能不再进入临界区（比如 P0 完成任务退出）。

- 此时：`turn = 1`，P0 已退出。

- **P1 开始运行**：
  - `while(turn != 1)` → 条件成立？`turn == 1`，所以不等待，进入临界区。
  - 执行完后，设置 `turn = 0`，表示“我把权利还给 P0”。

- 此时：`turn = 0`，但 **P0 已经不再运行**（空闲或退出）。

- **P1 再次想进入临界区**：
  - 它再次执行：
    ```c
    while (turn != 1);  // 现在 turn == 0，所以条件成立 → 无限等待！
    ```
  - 尽管 **临界区是空的**，P1 想进入，但它必须等 `turn == 1`。
  - 而 `turn` 只能由 P0 设为 1，但 **P0 已经不再运行**！

主要问题： 违背了 **空闲让进** 原则
> 当`turn = 0`，`P0`进程不需要访问临界区，`P1`进程需要访问临界区，这样就会导致`P1`不能访问，但此时临界区时空闲的。

**单标志法的缺陷：**

- 只用一个共享变量 `turn` 来控制进入权限。
- 它实现的是**轮流进入**（类似“击鼓传花”），而不是“谁想进且能进就进”。
- 它**强制交替执行**：P0 → P1 → P0 → P1 → …
- 如果某个进程暂时不想进，另一个进程也**必须等它“归还权利”**，即使对方永远不来了。

### 2.1.2 双标志先检查法

算法思想：设置一个布尔类型数组 `flag[]`，数组中各个元素用来标记 **各进程想进入临界区的意愿**，比如 `flag[0] = true` 意味着 0 号进程 P0 现在想进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 `flag[i]` 设为 `true`，之后开始访问临界区。

```C
bool flag[2] = {false, false};  // 初始：两个进程都不想进入临界区

// P0 进程
while (flag[1]);     // 如果 P1 想进，P0 就等待（先检查）
flag[0] = true;      // 然后声明：我要进
critical_section();  // 临界区
flag[0] = false;     // 退出后 P1 声明不再需要
remainder_section();

// P1 进程
while (flag[0]);     // 如果 P0 想进，P1 就等待
flag[1] = true;      // 声明我要进
critical_section();
flag[1] = false;
remainder_section();
```

问题：这种算法连“互斥”都无法保证！两个进程可能**同时进入临界区**，即**没有真正互斥**。

场景模拟：通过一个**典型并发执行场景**来说明，即经典竞态条件（Race Condition）演示

假设初始状态：

```c
flag[0] = false;
flag[1] = false;
```

执行顺序如下（时间从上到下）：

| 时间 | 事件 |
|------|------|
| t1   | P0 执行 `while (flag[1]);` → `flag[1] == false` → 条件不成立，跳出循环 |
| t2   | P1 执行 `while (flag[0]);` → `flag[0] == false` → 条件不成立，跳出循环 |
| t3   | P0 执行 `flag[0] = true;` |
| t4   | P1 执行 `flag[1] = true;` |
| t5   | P0 进入 **临界区** |
| t6   | P1 进入 **临界区** |

- P0 看到 P1 没想进（`flag[1]==false`），就认为“我可以进”。
- P1 同时也看到 P0 没想进（`flag[0]==false`），也认为“我可以进”。
- 两者**同时判断通过**，然后都设置 flag 并进入。

⚠️ 问题在于：**“检查”和“上锁”不是原子操作**！

- 检查时对方还没声明意愿，
- 但检查完后对方立刻声明了，
- 而自己已经跳过等待了。

这就导致了**两个进程都认为对方不忙，于是都进入**，即使其中一个已经“忙”了。

主要问题：违背了 **忙则等待** 原则
> 最开始，两个进程数组对应的值都为 `false`，两个进程同时访问临界区，由于都为 `false`，所以可以直接运行到 `while` 循环后。
> 原因： **检查（从 `while` 的判断开始）** 和 **上锁（到 `flag[i] = false` 结束）** 不能一气呵成。

### 2.1.3 双标志后检查法

算法思想：在双标志先检查法的基础上进行了改进， **先上锁，后检查** 。

```C
bool flag[2] = {false, false};  // 初始：都不想进

// P0 进程
flag[0] = true;           // 1. 先声明：我要进
while (flag[1]);          // 2. 再检查：如果 P1 也想进，我就等待
critical_section();       // 3. 进入临界区
flag[0] = false;          // 4. 退出
remainder_section();

// P1 进程
flag[1] = true;           // 1. 先声明：我要进
while (flag[0]);          // 2. 再检查：如果 P0 也想进，我就等待
critical_section();
flag[1] = false;
remainder_section();
```

场景模拟：执行顺序（竞态条件）如下：

| 时间 | 事件 |
|------|------|
| t1   | P0 执行 `flag[0] = true;` → 表示 P0 想进 |
| t2   | P1 执行 `flag[1] = true;` → 表示 P1 想进 |
| t3   | P0 执行 `while (flag[1]);` → `flag[1] == true` → 进入等待 |
| t4   | P1 执行 `while (flag[0]);` → `flag[0] == true` → 进入等待 |

结果：P0 在等 P1 放弃，P1 在等 P0 放弃 → 双方无限等待。

主要问题：违背了 **空闲让进** & **有限等待** 原则
> 可能两个进程同时上锁，导致谁都不能访问临界区，产生 **死等**。注意和死锁的区别！
> - 死等：一个或多个进程在**循环等待某个条件成立**，但该条件**永远不成立**，导致无限等待。
> - 死锁：两个或多个进程**无限等待对方释放资源**，导致所有进程都无法继续执行。

### 2.1.4 Peterson 算法

算法思想：结合双标志法，单标志法的思想。如果双方都争着进入临界区，那可以让进程尝试 **互相谦让**，即表达自己想进入临界区的意愿，但是先让别人访问。

```C
bool flag[2] = {false, false};    // 表示进入临界区意愿的数组(表达意愿)
int turn = 0;                     // 表示当前允许进入临界区的进程号(表示谦让)

// P0
flag[0] = true;           // 表达意愿：我想进
turn = 1;                 // 谦让：我把优先权让给 P1
while (flag[1] && turn == 1);  // 如果 P1 也想进，且优先权在 P1，我就在这儿等着（被循环卡住）
critical_section();
flag[0] = false;

// P1
flag[1] = true;
turn = 0;
while (flag[0] && turn == 0);
critical_section();
flag[1] = false;
```

> Peterson 算法中，不管以何种顺序执行，都会有一个进程被 while 循环卡住，另一个进程可以顺利访问临界资源，因为 `flag[i]` 不可能同时都为 `false`，且 `turn` 只表示一个当前允许进入临界区的进程号。

场景模拟：

```c
while (flag[1] && turn == 1);
```

这行代码是**自旋等待（spin-waiting）**：
- 如果 P1 也想进，且 `turn == 1`，P0 就会**一直循环检查条件**。
- 在这期间，P0 **并未释放 CPU**，而是不断执行 `while` 判断。
- 即使它暂时无法进入临界区，**仍然占用 CPU 资源**。

主要问题：违背了 **让权等待** 原则

## 2.2 互斥的硬件实现方法

**执行的过程不允许被中断，都是一气呵成！**

> **某些关键操作（比如检查并修改一个共享变量）必须以“原子操作”（Atomic Operation）的方式执行——整个过程，不可分割、不可中断，要么全部完成，要么完全没发生。**

### 2.2.1 中断屏蔽法

利用 **开/关中断指令** 实现：
- 在一个进程进入临界区之前，**先关闭中断**（屏蔽中断）；  
- 执行完临界区后，再**重新开启中断**。  
- 这样，在临界区执行期间，**不会发生时钟中断 → 不会发生进程调度 → 不会切换到其他进程**。

![alt text](imgs/开关中断.png)

- 优点：简单，高效
- 缺点：**不适用于多处理机**；只适用于操作系统内核程序，**不适用于用户进程**（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意适用就很危险）

### 2.2.2 Test and Set Lock（TS 指令/TSL 指令）

TSL 指令是一种由**硬件直接支持的原子指令**。

```C
// 布尔型共享变量 lock 表示当前临界区是否被加锁
// true 表示加锁，false 表示未加锁
bool TestAndSet(bool *lock) {
    bool old = *lock;   // 1. 读取 lock 的当前值
    *lock = true;       // 2. 将 lock 设为 true（上锁）
    return old;         // 3. 返回原来的值
}
```

> `TestAndSet(bool *lock)` 中的三步操作在硬件层面是**不可分割**的！从读取 `lock` 到写入 `true`，整个过程**不允许被中断、不允许其他处理器访问同一内存地址**。

以下是使用 TSL 指令实现互斥的算法逻辑:

```C
while (TestAndSet(&lock));   // 上锁并检查
critical_section();          // 临界区
lock = false;                // 退出时解锁
remainder_section();         // 剩余区
```

过程：
> 若刚开始 `lock` 是 `false`，则 TSL 返回的 `old` 值为 `false`，`while` 循环条件不满足，直接跳过循环，进入临界区。若刚开始 `lock` 是 `true`，则执行 TSL 后 `old` 返回的值为 `true`，`while` 循环满足条件，会一直循环，直到当前访问临界区的进程在退出区进行解锁。
> 相比于软件实现方法，TSL 指令把 **上锁** 和 **检查** 操作用硬件的方式变成了一气呵成的原子操作。

- 优点：实现简单，无需像软件实现那样严格检查是否会有逻辑漏洞； **适用于多处理机环境**。
- 缺点：不满足 **让权等待** 原则，暂时无法进入临界区的进程会占用 `CPU` 并循环执行 TSL 指令，从而导致忙等

### 2.2.3 Swap 指令（Exchange/XCHG 指令）

Swap 指令也是一种由**硬件直接支持的原子指令**。

```C
// Swap 指令的作用是交换两个变量的值
Swap (bool *a, bool *b) {
    bool temp = *a;
    *a = *b;
    *b = temp;
}
```

> `Swap (bool *a, bool *b)` 中的三步操作在硬件层面是**不可分割**的！中间不会发生进程切换或内存访问冲突。

以下是使用 TSL 指令实现互斥的算法逻辑：

```C
// lock 表示当前临界区是否被加锁
bool old = true；
while (old == true)
    Swap(&lock, &old);
critical_section();          // 临界区
lock = false;                // 解锁
remainder_section();         // 剩余区
```

过程：
> 逻辑上与 TSL 并无太大的区别，都是先记录下此时临界区是否已经被上锁（记录在 `old` 变量上），再将上锁标记 `lock` 设置为 `true`，最后检查 `old`，如果 `old` 为 `false` 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

- 优点：与 `TSL` 一样。
- 缺点：与 `TSL` 一样。

---

# 3.信号量机制

用户进程可以通过使用操作系统提供的 **一对原语** 来对信号量进程操作，从而很方便的实现了进程互斥、进程同步。

信号量其实就是一个**整型变量**（也可以是结构体），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。

> 信号量是由操作系统维护，它属于**低级进程通信（同步）原语**，其操作在操作系统中通常**以系统调用的形式提供**，不等同于“系统调用命令”本身。
> “以系统调用的形式提供”，是指用户程序会调用类似 `wait()` 或 `signal()` 这样的函数，这些函数在底层最终会触发一个系统调用。

**一对原语：** `wait(S)`、`signal(S)`，简称为 P 操作、V 操作。

| 原语 | 别名 | 作用 |
|------|------|------|
| `wait(S)` | P(S) | **申请资源**：如果资源可用，就使用；否则等待 |
| `signal(S)` | V(S) | **释放资源**：用完资源后，通知系统可以被其他进程使用 |

## 3.1 整型信号量

```C
int S = 1; // 初始化整型信号量 S，表示当前系统中可用的打印机资源数

// P 操作：申请资源
void wait(int S) {   // wait 原语，相当于 进入区
    while (S <= 0);  // 如果资源数不够，就一直循环等待（忙等）
    S = S - 1;       // 如果资源数够，则占用一个资源
}

// V 操作：释放资源
void signal(int S) { // signal 原语，相当于 退出区
    S = S + 1;       // 使用完资源后，在退出区释放资源
}

// 进程 P0
wait(S);              // 进入区，申请资源
// 使用打印机资源...
signal(S);            // 退出区，释放资源

// 进程 P1
wait(S);
// 使用打印机资源...
signal(S);

// .......

// 进程 Pn
wait(S);
// 使用打印机资源...
signal(S);
```

场景 1：P0 首次进入
- `S = 1`
- `while(S <= 0)` → `1 <= 0`？不成立 → 跳过循环
- `S = S - 1` → `S = 0`
- 进入临界区（使用打印机）

场景 2：P1 此时尝试进入
- `S = 0`
- `while(S <= 0)` → `0 <= 0` 成立 → 进入循环，**一直执行这个 while**
- `S = S - 1` 永远不会执行（因为卡在 while）
- P1 **持续占用 CPU 循环检查**，直到 P0 释放资源

场景 3：P0 退出
- 执行 `signal(S)` → `S = 0 + 1 = 1`
- 此时 P1 的 `while(S <= 0)` 变为 `1 <= 0`？不成立 → 跳出循环
- `S = S - 1` → `S = 0`
- P1 进入临界区

缺点：不满足 **让权等待** 原则，会发生 **忙等** 。

## 3.2 记录型信号量

用 **记录型数据结构** 表示信号量。

```C
/* 记录型信号量的定义 */
typedef struct {
    int value;          // 当前可用资源的数量
    struct process *L;  // 等待该资源的进程队列（阻塞队列）
} semaphore;

// P 操作：申请资源
void wait (semaphore S) {
    S.value--;
    // 判断资源是否够用
    if (S.value < 0) {
        block(S.L);    // 运行态 -> 阻塞态
    }
}

// V 操作：释放资源
void signal(semaphore S) {
    s.value++;
    // 判断是否有进程在等待
    if (S.value <= 0) {
        wakeup(S.L);  // 阻塞态 -> 就绪态
    }
}
```

信号量 `S` 的 `value` 表示：
- **可用资源的数量**
- 负数时，其**绝对值表示等待队列中的进程数量**

| `S.value` | 含义 |
|----------|------|
| `> 0` | 有 `S.value` 个资源可用 |
| `= 0` | 资源刚好用完，无人等待 |
| `< 0` | 资源不足，有 |S.value| 个进程在等待 |

- `wait` 操作是用来 **申请资源** 的，当信号量的值 `> 0` 时，进程就直接获得资源，信号量的值减 1；当信号量的值 `<= 0` 时，信号量的值减 1 就会变为负数，条件判断满足，进程必须进入等待队列，直到资源可用。所以判断条件用 `S.value < 0`。
- `signal` 操作的目的是唤醒 **最多一个进程**，并且只在信号量的值 `<= 0` 时才会有进程在等待，唤醒的是等待队列中的一个进程。所以判断条件用 `S.value <= 0`。

场景模拟：

1. `wait` （P）操作：某进程需要使用资源时，通过 `wait` 原语申请
	
| 场景 | 说明 |
|------|------|
| `S.value > 0` | `S.value--` 后仍 ≥0 → 直接进入临界区 ✅ |
| `S.value == 0` | `S.value--` → `-1` → `< 0` → 进程被 `block` ❌ |
| `S.value < 0` | 表示已有进程在等待，当前进程也应被阻塞 ❌ |

> `block(S.L)` 的作用：
> - 将当前进程从**运行态 → 阻塞态**
> - 插入到 `S.L` 队列中
> - **主动让出 CPU**，不再占用处理器（满足**让权等待**）

2. `signal` （V）操作：进程使用完资源后，通过 `signal` 原语释放
	
| 场景 | 说明 |
|------|------|
| `S.value <= 0` | 表示有进程在 `S.L` 中等待 → 应唤醒一个 ✅ |
| `S.value > 0` | 没有进程等待 → 不需要唤醒 ❌ |

> `wakeup(S.L)` 的作用：
> - 从 `S.L` 中取出一个进程
> - 将其从**阻塞态 → 就绪态**
> - 插入就绪队列，等待调度

## 3.3 总结

对于两种信号量，只需要记住 **P 操作减少资源数，V 操作增加资源数** 即可。 

整型信号量与记录型信号量的对比：

| 对比项 | 整型信号量 | 记录型信号量 |
|--------|------------|--------------|
| 数据结构 | `int S` | `struct { int value; queue L; }` |
| 等待方式 | 忙等（`while(S<=0)`） | 阻塞（`block`） |
| 是否让权等待 | ❌ 否 | ✅ 是 |
| CPU 利用率 | 低（浪费在循环） | 高（等待进程不占 CPU） |
| 适用性 | 仅理论/教学 | 操作系统实际使用 |
| 原子性 | 不保证 | 由操作系统保证 |

---

# 4.P、V 操作的应用

用信号量机制实现进程同步、互斥、前驱关系。

## 4.1 同步关系（一前一后）

进程同步：要让各并发进程按要求有序地推进

- 分析什么地方需要实现 同步关系，即必须保证 **一前一后** 执行的两个操作
- 设置同步信号量`S`，初始值为`0`
- 在 **前操作** 之后执行`V(S)`
- 在 **后操作** 之前执行`P(S)`

```C
/**
 * 要求：后操作（代码4）需要在前操作（代码1和代码2）执行后才可以执行
 */
P1() {
    // 代码1
    // 代码2
    V(S);       // 前操作完成，发信号
    // 代码3
}
P2() {
    P(S);  //如果代码1和代码2没有执行完，就会主动请求阻塞
    // 代码4
    // 代码5
    // 代码6
}
```

执行过程模拟，假设 `S` 初始为 `0`

- 情况一：若 P1 先运行：

| 时间 | 事件 | `S.value` | P2 是否阻塞 |
|------|------|-----------|-------------|
| t1   | P1 执行 `代码1`、`代码2` | `0` | — |
| t2   | P1 执行 `V(S)` | `0 → 1` | — |
| t3   | P2 执行 `P(S)` | `1 → 0` | 不阻塞，继续执行 `代码4` ✅ |

- 情况二：若 P2 先运行：

| 时间 | 事件 | `S.value` | P2 是否阻塞 |
|------|------|-----------|-------------|
| t1   | P2 执行 `P(S)` | `0 → -1` | ❌ 阻塞（因为 `S.value < 0`） |
| t2   | P1 执行 `代码1`、`代码2` | — | P2 仍阻塞 |
| t3   | P1 执行 `V(S)` | `-1 → 0` | ✅ 唤醒 P2 |
| t4   | P2 被唤醒，继续执行 `代码4` | | ✅ |

> 无论哪个进程先运行，都能保证：**代码4 一定在 代码1 和 代码2 之后执行**。

## 4.2 互斥关系（错开访问）

> 需要访问互斥的例子：
> - 两个进程同时打印文档 → 打印机输出混乱。
> - 两个进程同时写同一个文件 → 数据覆盖。
> - 两个线程同时修改一个计数器 → 计数错误。
> 
> 所以必须保证：**同一时间只有一个进程能访问临界资源**。

即，当两个进程需要**修改同一个全局变量**时。

1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应该放在临界区）
2. 设置互斥信号量`mutex`，初值为`1`
3. 在进入区`P(mutex)` —— 申请资源
4. 在退出区`V(mutex)` —— 释放资源

注意：对于 **不同的临界资源** 需要设置 **不同的互斥信号量**

![alt text](imgs/互斥关系.png)

```C
semaphore mutex = 1;  // 互斥信号量，初值为 1，表示“有一个资源可用”或“锁是打开的”

P1() {
    // 非临界区
    P(mutex);      // 进入区：申请进入临界区
    use_printer(); // 临界区：使用打印机
    V(mutex);      // 退出区：释放临界区
    // 非临界区
}

P2() {
    // 非临界区
    P(mutex);      // 进入区
    use_printer(); // 临界区：使用打印机
    V(mutex);      // 退出区
    // 非临界区
}
```

| 概念 | 说明 |
|------|------|
| **互斥信号量 `mutex`** | 表示临界资源的“可用状态” |
| **初值 `1`** | 表示资源初始可用 |
| **`P(mutex)` 在进入区** | 申请资源，如果被占用就阻塞 |
| **`V(mutex)` 在退出区** | 释放资源，唤醒等待者 |

## 4.3 前驱关系

- 要为每一对前驱关系各设置一个同步信号量
- 在 **前操作** 之后对相应的同步信号量执行`V`操作
- 在 **后操作** 之前对相应的同步信号量执行`P`操作

![alt text](imgs/前驱关系.png)

---

# 5.经典同步问题

## 5.1 多生产者-单消费者问题

1. **问题描述：
**系统中有 **一组生产者（多个）** 进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用（注：这里的“产品”理解为某种数据） 。

2. **核心约束：**
	- 生产者、消费者共享一个初始为空、大小为 `n` 的缓冲区
	- 缓冲区**不能满时还生产**（否则数据丢失）
	- 缓冲区**不能空时还消费**（否则无数据可取）
	- 缓冲区是**临界资源**，必须互斥访问

![alt text](imgs/生产者消费者问题.png)

```C
semaphore mutex = 1;  // 互斥信号量，实现对缓冲区的互斥访问
semaphore empty = n;  // 同步信号量，表示空闲缓冲区的数量
semaphore full = 0;  // 同步信号量，表示已用缓冲区数量（产品数）

// 生产者
producer() {
    // 生产一个产品...
    P(empty);           // 申请一个空缓冲区（同步）
    P(mutex);           // 进入临界区（互斥）
    // 将产品放入缓冲区
    V(mutex);           // 退出临界区
    V(full);            // 释放一个“产品”资源，唤醒消费者
}

// 消费者
consumer() {
    P(full);            // 申请一个产品（同步）
    P(mutex);           // 进入临界区（互斥）
    // 从缓冲区取出一个产品
    V(mutex);           // 退出临界区
    V(empty);           // 释放一个空位，唤醒生产者
    // 使用产品...
}
```

1. **同步关系（Synchronization）**
	- 生产者必须等待 `empty > 0` 才能生产 → `P(empty)`
	- 消费者必须等待 `full > 0` 才能消费 → `P(full)`

2. **互斥关系（Mutual Exclusion）**
	- 缓冲区是共享资源，多个生产者或消费者不能同时修改它。
	- 使用 `mutex = 1` 实现互斥访问。

**执行流程示例：**

1. 生产者执行：
	- `P(empty)`：等待有空位
	- `P(mutex)`：获取缓冲区访问权
	- 放入产品
	- `V(mutex)`：释放缓冲区
	- `V(full)`：通知消费者“有新产品了”

2. 消费者执行：
	- `P(full)`：等待有产品
	- `P(mutex)`：获取缓冲区访问权
	- 取出产品
	- `V(mutex)`：释放缓冲区
	- `V(empty)`：通知生产者“有空位了”

> 思考：能否改变互斥和同步的 P、V 操作的顺序？
> - 不可以，会产生死锁
> - 实现互斥的 P 操作一定要在实现同步的 P 操作之后

错误的顺序一：

```C
producer() {
    P(mutex);   // 先锁住缓冲区
    P(empty);   // 再申请空位
    // 放入产品...
    V(full);
    V(mutex);
}
```

问题：
- 如果缓冲区已满 → `P(empty)` 会阻塞
- 但此时 `mutex` 已被占用（锁着）
- 消费者想取产品 → 需要 `P(mutex)` → 被阻塞
- 消费者无法取走产品 → `empty` 永远不会增加 → `P(empty)` 永远等待先`P(mutex)`，如果缓冲区已 **满** ，`P(empty)`会阻塞，但此时锁不会释放，导致消费者无法`P(mutex)`，形成死锁！

错误的顺序二：

```C
consumer() {
    P(mutex);   // 先锁住缓冲区
    P(full);    // 再申请产品
    // ...
    V(empty);
    V(mutex);
}
```

问题：
- 如果缓冲区为空 → `P(full)` 阻塞
- 但 `mutex` 已被占用
- 生产者想生产 → 需要 `P(mutex)` → 被阻塞
- 生产者无法放入产品 → `full` 永远不增加 → `P(full)` 永远等待

错误顺序三：

```C
producer() {
    P(empty);
    // 忘记 P(mutex)
    // 多个生产者同时修改缓冲区指针 → 数据混乱
    V(full);
}
```

忘记 `P(mutex)`，多个生产者可能同时修改缓冲区，导致数据竞争和破坏。

## 5.2 多生产者-多消费者问题

1. **问题描述：**
桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。 用 P、V 操作实现上述过程。

2. **问题本质：谁在做什么？**

| 进程 | 行为 |
|------|------|
| **父亲** | 只生产苹果，放入盘子 |
| **母亲** | 只生产橘子，放入盘子 |
| **女儿** | 只消费苹果，从盘子取走苹果 |
| **儿子** | 只消费橘子，从盘子取走橘子 |
| **盘子** | 缓冲区，**每次只能放一个水果**（大小为 1） |

3. **核心约束：**
	- **盘子空时**，父亲或母亲才能放水果
	- **盘子有苹果时**，女儿才能取苹果
	- **盘子有橘子时**，儿子才能取橘子
	- **盘子一次只能放一个水果** → 本质是 **容量为 1 的缓冲区**
	- 多个进程并发访问盘子 → 必须保证**正确性和互斥性**

```C
semaphore mutex  = 1;   // 互斥访问盘子
semaphore plate  = 1;   // 盘子是否空（可放水果）
semaphore apple  = 0;   // 苹果是否在盘中
semaphore orange = 0;   // 橘子是否在盘中

father() {
    while (1) {
        P(plate);       // 等待盘子空
        P(mutex);       // 获取盘子访问权
        // 放苹果
        V(mutex);       // 释放盘子
        V(apple);       // 通知女儿：苹果来了！
    }
}

mother() {
    while (1) {
        P(plate);       // 等待盘子空
        P(mutex);       // 获取盘子访问权
        // 放橘子
        V(mutex);       // 释放盘子
        V(orange);      // 通知儿子：橘子来了！
    }
}

daughter() {
    while (1) {
        P(apple);       // 等待苹果被放入
        P(mutex);       // 获取盘子访问权
        // 取苹果
        V(mutex);       // 释放盘子
        V(plate);       // 通知：盘子空了，可以放水果了
        // 吃苹果
    }
}

son() {
    while (1) {
        P(orange);      // 等橘子
        P(mutex);       // 获取盘子访问权
        // 取橘子
        V(mutex);
        V(plate);       // 盘子空了
        // 吃橘子
    }
}
```

**执行流程示例：**

| 顺序 | 事件 | 信号量状态 |
|------|------|-------------|
| 1 | 初始 | `plate=1`, `apple=0`, `orange=0` |
| 2 | 父亲 `P(plate)` | `plate=0`，盘子被占用 |
| 3 | 父亲放苹果 | `V(apple)` → `apple=1` |
| 4 | 女儿 `P(apple)` | 成功，进入 |
| 5 | 女儿取苹果 | `V(plate)` → `plate=1`，盘子空 |
| 6 | 母亲 `P(plate)` | 成功，放橘子 |
| 7 | 母亲 `V(orange)` | `orange=1` |
| 8 | 儿子 `P(orange)` | 成功，取橘子 |
| 9 | 儿子 `V(plate)` | `plate=1`，循环继续 |

**思考：可以不用 `mutex` 吗？**

> **对于缓冲区大小为 1 的情况，可以不设置 `mutex`！**

原因：
- `plate` 信号量已经保证了：**只有盘子空时才能放水果**
- `apple` 和 `orange` 保证了：**只有水果在盘中才能取**
- 而盘子只能放一个水果 → **任何时候最多只有一个进程在操作盘子**

换句话说：**`plate`、`apple`、`orange` 这三个同步信号量已经隐含了互斥性**。

省略 `mutex` 的代码：

```c
father() {
    P(plate);
    // 放苹果
    V(apple);
}

daughter() {
    P(apple);
    // 取苹果
    V(plate);
}
```

> 但当缓冲区 > 1 时，必须用 `mutex`！因为要保证只有一个进程在缓冲区中。

## 5.3 读者-写者问题

1. **问题描述：**
有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。

2. **问题本质**

| 操作 | 特点 |
|------|------|
| **读操作（Read）** | 多个读者可以**同时读**，不会破坏数据 |
| **写操作（Write）** | 写操作会修改数据，必须**独占访问**，不能与其他读或写并发 |

3. **核心要求**
	- **允许多个读者同时读**（提高并发性）
	- **只允许一个写者写**（互斥）
	- **写者写时，不能有读者读**（避免脏读）
	- **读者读时，不能有写者写**（避免读到不一致数据）
	- **写者写前，必须等所有读者和写者退出**（强互斥）

### 5.3.1 方式一： 读优先

```C
semaphore rw = 1;     // 用于实现对共享文件的互斥访问
int count = 0;        // 记录当前有几个读进程在访问文件
semaphore mutex = 1;  // 用于保证对 count 变量的互斥访问

writer() {
    P(rw);       // 申请写权限（独占）
    // 写文件
    V(rw);       // 释放
}

reader() {
    P(mutex);                    // 保护 count
    if (count == 0) {            // 第一个读者
        P(rw);                   // 加锁，阻止写者进入
    }
    count++;                     // 读者数 +1
    V(mutex);

    // 读文件...

    P(mutex);
    count--;                     // 读者数 -1
    if (count == 0) {            // 最后一个读者
        V(rw);                   // 解锁，允许写者进入
    }
    V(mutex);
}
```

1. 关键思想：
	- **第一个读者** 负责 `P(rw)` → 阻止写者进入
	- **最后一个读者** 负责 `V(rw)` → 允许写者进入
	- 中间的读者无需操作 `rw`，可以直接读
	- `mutex` 保护 `count` 的修改

2. 优点：
	- 读并发性高，适合读多写少场景（如数据库查询）

3. 缺点：
	- **写者可能饿死（Starvation）** ：如果读者源源不断到来，`count` 始终 > 0，`V(rw)` 永远不执行，写者一直等待。

### 5.3.2 方式二： 读写公平

```C
semaphore rw = 1;     // 用于实现对共享文件的互斥访问
int count = 0;        // 记录当前有几个读进程在访问文件
semaphore mutex = 1;  // 用于保证对 count 变量的互斥访问
semaphore w = 1;      // 新增信号量，用于控制写者优先权

writer() {
    P(w);        // 进入写者队列（抢占“写优先权”）
    P(rw);       // 申请文件独占
    // 写文件
    V(rw);
    V(w);        // 释放写优先权
}

reader() {
    P(w);        // 申请“可以读”的权利
    P(mutex);
    if (count == 0) {
        P(rw);   // 第一个读者加锁
    }
    count++;
    V(mutex);
    V(w);        // 立即释放 w，允许其他读者或写者竞争
    
    // 读文件...
    
    P(mutex);
    count--;
    if (count == 0) {
        V(rw);   // 最后一个读者解锁
    }
    V(mutex);
}
```

1. 关键思想：
	- `P(w)` 和 `V(w)` 像一道“闸门”
	- 一旦写者执行 `P(w)`，后续读者的 `P(w)` 会被阻塞
	- 写者可以“插队”，避免饿死
2. 优点：
	- **写者不会饿死**
	- 读写更公平

3. 缺点：
	- 读并发性降低，新读者必须等待写者完成

## 5.4 哲学家进餐问题

1. **问题描述**：
	- 5 位哲学家围坐在圆桌旁
	- 每两人之间有一根**筷子**（共 5 根）
	- 哲学家要么**思考**，要么**进餐**
	- 进餐需要**同时拿起左右两根筷子**
	- 每根筷子是**临界资源**，只能一人使用
	- 拿筷子是**原子操作**：一次只能拿一根

2. **死锁场景**：如果规定所有的哲学家都先拿左手边的筷子，再拿右手边的筷子，但右手筷子被右边哲学家拿着，因此每个人都在等右边的筷子，这样就导致死锁。

要发生死锁，必须同时满足以下四个条件：
- 互斥（筷子只能一人用）
- 占有并等待（拿着一根，等另一根）
- 非抢占（不能抢别人筷子）
- 循环等待（`P0 → P1 → P2 → P3 → P4 → P0`）

### 5.4.1 方法一：限制并发数量

> 思想：只允许最多 4 个哲学家同时尝试拿筷子 → 至少有一个人能拿到两根筷子，避免全局等待。

```C
semaphore chopstick[5] = {1, 1, 1, 1, 1};
semaphore seat = 4;   // 最多 4 人入座

// i 号哲学家进餐
Pi() {
    P(seat);                    // 申请进入
    P(chopstick[i]);
    P(chopstick[(i+1)%5]);
    // 吃饭
    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
    V(seat);                    // 离开
    // 思考
}
```

这种方式一定能打破**循环等待**，至少有一人能进餐，不会死锁。

### 5.4.2 方法二：奇偶号哲学家拿筷子顺序不同

> 思想：打破对称性，避免所有哲学家“同向拿筷子”。
> - **奇数号哲学家**：先拿**左边**，再拿**右边**
> - **偶数号哲学家**：先拿**右边**，再拿**左边**

```C
semaphore chopstick[5] = {1, 1, 1, 1, 1};

Pi() {
    if (i % 2 == 1) {  // 奇数
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
    } else {           // 偶数
        P(chopstick[(i+1)%5]);
        P(chopstick[i]);
    }
    // 吃饭
    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
}
```

为什么能避免死锁？
- 相邻两人拿筷子方向相反
- 不可能同时持有一根、等另一根
- 形不成“循环等待链”

破坏了**循环等待**条件，避免死锁。

### 5.4.3 方法三：原子性地拿两根筷子（推荐）

> 思想：只有当**左右两根筷子都可用**时，才允许哲学家拿起它们。否则，一根都不拿。这需要一个**互斥信号量 `mutex`** 来保护“判断+拿筷子”这一组操作。

```C
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1;  // 互斥访问“拿筷子”操作

Pi() {
    while (1) {
        // 思考...
        
        P(mutex);  // 进入临界区：原子操作
        P(chopstick[i]);           // 拿左边
        P(chopstick[(i+1)%5]);     // 拿右边
        V(mutex);  // 拿完左右两边的筷子后再退出临界区
        
        // 吃饭...
        
        V(chopstick[i]);           // 放左边筷子
        V(chopstick[(i+1)%5]);     // 放右边筷子
        // 继续思考
    }
}
```

- `P(mutex)` 保证“拿两根筷子”是一个**原子操作**
- 不会出现“拿了左边，右边被抢”的情况
- 一旦进入，就一定能拿到两根筷子

**优点**：逻辑清晰，避免死锁  
**缺点**：并发性降低（同一时间只能一人尝试拿筷子）

## 5.5 吸烟者问题（补充）

1. **问题描述：**
假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)。

2. **问题本质：谁在做什么？**

| 进程 | 拥有的资源 | 需要的资源 |
|------|------------|------------|
| **供应者（Provider）** | 无限供应三种材料：烟草、纸、胶水 | 每次放**两种材料**在桌上 |
| **抽烟者1（Smoker 1）** | 拥有 **烟草** | 需要 **纸 + 胶水** |
| **抽烟者2（Smoker 2）** | 拥有 **纸** | 需要 **烟草 + 胶水** |
| **抽烟者3（Smoker 3）** | 拥有 **胶水** | 需要 **烟草 + 纸** |

3. **核心约束**
	- 供应者每次随机（或轮流）放两种材料在桌上。
	- **拥有第三种材料的抽烟者** → 可以卷烟 → 抽完 → 通知供应者 → 供应者继续放新材料。
	- 三个抽烟者轮流抽烟

4. **同步关系**
	1. **供应者 → 抽烟者：同步**
		- 供应者放材料 → 抽烟者才能拿
		- 每种材料组合对应一个信号量：
		  - `offer1`：桌上是 **纸 + 胶水** → 抽烟者1（有烟草）可以卷烟
		  - `offer2`：桌上是 **烟草 + 胶水** → 抽烟者2（有纸）可以卷烟
		  - `offer3`：桌上是 **烟草 + 纸** → 抽烟者3（有胶水）可以卷烟

	2. **抽烟者 → 供应者：同步**
		- 抽烟者抽完 → 通知供应者可以放新材料
		- 使用 `finish` 信号量实现“完成通知”

```C
semaphore finish = 1;  // 抽烟是否完成，初始为 0（没人抽完）
semaphore offer1 = 0;  // 桌上有“纸+胶水”？
semaphore offer2 = 0;  // 桌上有“烟草+胶水”？
semaphore offer3 = 0;  // 桌上有“烟草+纸”？
int i = 0;             // 控制供应者轮流放材料

provider() {
    while (1) {
	    P(finish);      // 等待抽烟者抽完
        if (i == 0) {
            V(offer1);  // 放“纸+胶水”
        } else if (i == 1) {
            V(offer2);  // 放“烟草+胶水”
        } else {
            V(offer3);  // 放“烟草+纸”
        }
        i = (i + 1) % 3;  // 轮流   
    }
}

smoker1() {
    while (1) {
        P(offer1);
        // 拿走组合一
        V(finish);
    }
}

smoker2() {
    while (1) {
        P(offer2);
        // 拿走组合二
        V(finish);
    }
}

smoker3() {
    while (1) {
        P(offer3);
        // 拿走组合三
        V(finish);
    }
}
```

**执行流程示例：**

| 步骤 | 事件 | 信号量变化 |
|------|------|-------------|
| 1 | 初始 | 所有 `offer=0`, `finish=0` |
| 2 | 供应者 `i=0` → `V(offer1)` | `offer1=1` |
| 3 | 抽烟者1 `P(offer1)` → 成功 | `offer1=0`，开始抽烟 |
| 4 | 抽烟者1 `V(finish)` | `finish=1` |
| 5 | 供应者 `P(finish)` → 成功 | `finish=0`，继续 |
| 6 | 供应者 `i=1` → `V(offer2)` | `offer2=1` |
| 7 | 抽烟者2 `P(offer2)` → 成功 | 开始抽烟 |
| 8 | 抽烟者2 `V(finish)` | `finish=1` |
| 9 | 供应者 `P(finish)` → 继续 | 循环下去 |

这个解法是已经 **假设了供应者知道顺序**，即供应者是**按固定顺序**放材料（`i=0,1,2` 轮流），这相当于：**供应者知道谁会响应，且按顺序唤醒抽烟者**

原始吸烟者问题的挑战：
- 供应者**不知道**哪个抽烟者会响应
- 材料是**随机放置**的
- 要求：**只有拥有缺失材料的抽烟者才能响应**

Suhas Patil 证明了一个著名结论：**仅用 P/V 操作（信号量）无法解决“真正的吸烟者问题”**，如果不能使用 `if-else` 判断或中断机制。

原因：
- 供应者无法根据桌上材料“动态唤醒”正确的抽烟者
- 信号量是“无名”的，不能表达“哪种组合被放置”
- 如果供应者随机放材料，可能唤醒错误的抽烟者

> 所以这个题目常被用来说明：**信号量虽然强大，但也有表达能力的局限性。**

---

# 6.管程

引入管程的原因：信号量机制存在编写程序困难、易出错的问题。因此设计一种机制，让程序员写程序的时候不需要再关心复杂的 P、V 操作。

信号量的痛点：

| 问题 | 说明 |
|------|------|
| **P/V 必须成对出现** | 漏写 `V(S)` 会导致死锁，多写会导致资源计数错误 |
| **顺序敏感** | `P(mutex)` 和 `P(empty)` 顺序错了会导致死锁 |
| **分散在代码中** | 同步逻辑分散，难以维护 |

将 P、V 操作 **封装到具体问题的类中** ，使用的时候就直接调用方法即可。

| 管程（Monitor） | 类（Class） | 说明 |
|------------------|-------------|------|
| 管程内的数据只能被管程内的方法访问 | 类的私有变量只能被类的方法访问 | 封装性 |
| 外部进程通过方法访问共享数据 | 外部通过方法访问私有变量 | 接口化 |
| 每次只允许一个进程在管程内执行 | 类的实例方法在多线程中需同步 | 互斥性 |

**管程的基本特征**：
1. 局部于管程的数据只能被局部于管程的过程所访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程

## 6.1 用管程解决生产者消费者问题

```cpp
#include <iostream>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>

const int N = 5;  // 缓冲区大小

class Monitor {
private:
    std::queue<int> buffer;  // 缓冲区
    int count = 0;           // 计数器
    std::mutex mtx;          // 互斥锁
    std::condition_variable full, empty;  // 条件变量

public:
    // 生产者插入产品
    void insert(int item) {
        std::unique_lock<std::mutex> lock(mtx);
        while (count == N) {
            full.wait(lock);  // 缓冲区满，等待
        }
        buffer.push(item);
        count++;
        std::cout << "Produced: " << item << "\n";

        if (count == 1) {
            empty.notify_one();  // 唤醒消费者
        }
    }

    // 消费者取走产品
    int remove() {
        std::unique_lock<std::mutex> lock(mtx);
        while (count == 0) {
            empty.wait(lock);  // 缓冲区空，等待
        }
        int item = buffer.front();
        buffer.pop();
        count--;
        std::cout << "Consumed: " << item << "\n";

        if (count == N - 1) {
            full.notify_one();  // 唤醒生产者
        }
        return item;
    }
};

// 创建全局管程
Monitor producerConsumer;

// 生产者线程
void producer() {
    for (int i = 0; i < 10; ++i) {
        producerConsumer.insert(i);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));  // 模拟生产时间
    }
}

// 消费者线程
void consumer() {
    for (int i = 0; i < 10; ++i) {
        producerConsumer.remove();
        std::this_thread::sleep_for(std::chrono::milliseconds(150));  // 模拟消费时间
    }
}

// 主函数
int main() {
    std::thread p1(producer);
    std::thread c1(consumer);

    p1.join();
    c1.join();

    return 0;
}
```