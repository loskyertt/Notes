# 1.装入方式

## 1.1 绝对装入

在编译时，如果知道程序将放在内存的位置，编译程序就直接 **产生绝对地址的目标代码** 。适用于 **早期单道程序阶段** 的时候（无 OS）。

**缺点：** 如果分配的内存地址发生改变，需要重新编译链接生成新的目标代码，灵活性不高。

## 1.2 可重定位装入（静态重定位）

编译链接生成目标代码的时候，依然生成相对地址，当装入内存的时候， **把所有地址都加上起始物理地址** 。适用于 **早期多道批处理阶段** 。

**缺点：** 在装入一个作业时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能够装入该作业。作业一旦装入内存，在运行期间也不可以移动，也不可以申请新的内存空间。

## 1.3 动态运行时装入（动态重定位）

装入内存的时候，依然采用相对地址，把地址转换工作推迟到程序真正要执行时才进行。需要借用一个 **重定位寄存器** 的支持，重定位寄存器中 **保存装入模块存放的起始位置** 。适用于 **现代操作系统** 。

**特点：**
- 可将程序分配到不连续的内存空间中
- 运行某一部分代码时，装入相应的代码即可
- 便于用户共享程序段

---

# 2.链接方式

## 2.1 静态链接

在程序运行之前，先将各目标模块及它们所需的库函数连接成 **一个完整的** 可执行文件（转入模块），之后不再拆开。

![alt text](imgs/静态链接.png)

## 2.2 装入时动态链接

将各目标模块装入内存时，**边装入边链接** 的方式。依赖的动态库在 **程序启动时就已经被加载** （注意与运行时动态链接的区别）。

![alt text](imgs/装入时动态链接.png)

## 2.3 运行时动态链接

在执行程序中 **需要用到的目标模块才对它进行链接** 。可以方便 **修改** 和 **更新** ，便于对目标模块的 **共享** 。

![alt text](imgs/运行时动态链接.png)

---

# 2.内存管理

![alt text](imgs/内存管理基本概念.png)

## 2.1 存储保护（简述）

> **定义：** 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。

- **方法一：** 在 CPU 中设置一对 **上、下限寄存器** ，存放进程的上、下限地址。进程的指令要访问某个地址时， CPU 检查是否越界。

![alt text](imgs/存储保护01.png)

- **方法二：** 采用 **重定位寄存器** （基址寄存器）和 **界地址寄存器** （限长寄存器）进行越界检查。
  - 重定位寄存器：存放进程的 **起始物理位置** ；
  - 界地址寄存器：存放进程的 **最大逻辑地址（进程的大小）** 。

![alt text](imgs/存储保护02.png)

---

# 3.内存空间的分配与回收

## 3.1 单一连续分配

在单一连续分配方式中，内存被分为 **系统区** 和 **用户区** 。系统区常常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。

内存中 **只能有一道用户程序** ，用户程序独占整个用户区空间（早期的单道程序阶段）。

- **优点：** 实现简单；无外部碎片；可以采用覆盖技能扩充内存；不一定需要采取内存保护（因为只有一道用户程序）。
- **缺点：** 只能用于单用户、单任务的操作系统中； **有内部碎片** ，存储器利用率极低。

## 3.2 固定分区分配

为了可以装入多道程序，且这些程序之间又不会互相干扰，于是将整个用户空间划分为 **若干个固定大小** 的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

![alt text](imgs/固定分区示意图.png)

1. 分区大小相等：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合。
2. 分区大小不等：增加了灵活性，可以满足大小不同的进程需求，根据常在系统中运行的作业情况进行划分（划分多个小分区、适量中等分区、少量大分区）。

操作系统需要建立一个数据结构—— **分区说明表** ，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区的大小排列。每个表项包括： **分区的大小、起始状态、状态（是否分配）** 。

![alt text](imgs/分区说明表1.png)

- **优点：** 实现简单、无外部碎片
- **缺点：** 
  - 当用户程序太大，可能没有一个分区满足要求，不得不采用覆盖技术，会降低性能。
  - 会 **产生内部碎片** ，内存利用率低。

## 3.3 动态分区分配（可变分区分配）

定义：不会预先分配分区，而是进程装入内存时， **根据进程的大小动态地建立分区** 。

### 3.3.1 记录内存的数据结构

**空闲分区表** 或者 **空闲分区链** 。

![alt text](imgs/分区表和链表.png)

### 3.3.2 空闲分区的选择

把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区中选择一个分区分配给该作业。可参考 **3.4 动态分区匹配算法** .

### 3.3.3 分区的分配 & 回收

1. **分配：**

   - 情况一：当从空闲分区表中选择一个分区分配后，内存还有剩余，则修改表项。
   - 情况二：当从空闲分区表中选择一个分区分配后，刚刚好分配完，则删除该表项。

2. **回收：**

    - 情况一：回收区后面有一个相邻的空闲分区，则合并。
    - 情况二：回收区前面有一个相邻的空闲分区，则合并。
    - 情况三：回收区前后各有一个相邻的空闲分区，则三个合并为一个。
    - 情况四：回收区前后无相邻的空闲分区，则新增一个表项。

**内部碎片：** 分配给某些进程的内存区域中，有些部分没有用上。
**外部碎片：** 内存中某些空闲的分区由于太小而难以利用。

如果内存中零碎的空间太多，导致无法满足内存较大的进程，可采用 **拼凑技术** 来解决外部碎片。

**注：** 动态分区分配应该使用 **动态重定位装入** （原因：绝对装入，地址改变时需要重新编译；静态装入，不支持移动）。

---

## 3.4 动态分区匹配算法

### 3.4.1 首次适应算法（First Fit）

- **算法思想：** 每次都从 **低地址** 开始查找，找到第一个能满足大小的空闲分区。
- **实现方法：** 空闲分区 **以地址递增** 的次序开始排序。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区。

### 3.4.2 最佳适应算法（Best Fit）

- **算法思想：** 考虑大内存的进程有地可留， **优先使用更小内存** 的空闲区。
- **实现方法：** 空闲分区 **按容量递增** 次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区。
- **缺点：** 每次都选小内存的分区进行分配，会留下越来越多很小的、难以利用的内存块。因此这种方法会 **产生很多外部碎片** 。

### 3.4.3 最坏适应算法（Worst Fit）

又称 **最大适应算法（Largest Fit）**

- **算法思想：** 避免留下越来越多的小内存块， **优先使用更大内存** 的空闲块。
- **实现方法：** 空闲分区 **按容量递减** 次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区。
- **缺点：** 导致更快是使用完大内存的空闲块，使之后的大内存的进程无分区可用。

### 3.4.4 邻近适应算法（Next Fit）

- **算法思想：** 首次适应算法，每次都从低地址开始遍历，导致低地址产生越来越多很小的空闲块。新来一个进程就重新从头开始遍历，会增加查找的开销。邻近适应算法就是接着 **从上一次查找结束的位置开始检索** 。
- **实现方法：** 空闲分区 **按地址递增** 次序排列（可排成一个 **循环** 列表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到第一个满足大小的空闲分区。
- **优点：** 无论低地址还是高地址都有相同的概率被使用。
- **缺点：** 可能导致了高地址部分的大分区更可能被使用（因为等概率使用嘛），划分为小分区，最后导致无大分区可用（和 **最坏适应算法** 的缺点类似）。

### 3.4.5 总结和对比

综合来看，四种算法中， **首次适应算法** 的效果反而更好。

| 算法   | 算法思想                      | 分区排列顺序          | 优点                                  | 缺点                                         |
| ---- | ------------------------- | --------------- | ----------------------------------- | ------------------------------------------ |
| 首次适应 | 从头到尾找适合的分区                | 按地址递增           | 综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序 |                                            |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区        | 按容量递增           | 会有更多的大分区被保留下来，更能满足大进程需求             | 会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区表重新排序 |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片  | 按容量递减           | 可以减少难以利用的小碎片                        | 大分区容易被用完，不利于大进程；算法开销大（需要重新排序）              |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 按地址递增（可排列成循环链表） | 不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应算法）  | 会使高地址的大分区也被用完                              |

---

# 4.基本分页存储管理

## 4.1 分页管理概念

将内存分为一个个 **相等的分区** ，每个分区就是一个 **页框** （页框 = 页帧 = 内存块 = 物理块 = 物理页面）。

每个页框都有一个编号，即**页框号**，页框号从 `0` 开始。

> 页框 = 页帧 = 内存块 = 物理块 = 物理页，这些术语都是同义词。

将进程的逻辑地址空间分为与页框相等的一个个部分，每个部分称为一个 **页** （页面） 。每个页也有一个编号，即 **页号** ，页号也从 `0` 开始。

操作系统 **以页框为单位** 为各个进程分配内存空间，进程的每个页被装入一个页框中，**页与页框之间通过页表建立映射关系**，这种映射不要求连续，也不要求所有页都在内存中（支持虚拟内存）。

> “一一对应”是指**每个逻辑页映射到一个物理页框**，但：
>> - **不是连续映射**！逻辑页 0 可以映射到物理页框 5，页 1 映射到页框 2，不要求连续。
>> - **不一定所有页都常驻内存**：在虚拟内存系统中，某些页可能被换出到磁盘（不在任何页框中）。

| 名称                   | 对应什么       | 属于哪一类地址空间 | 作用                   |
| ---------------------- | -------------- | ------------------ | ---------------------- |
| 页（Page）             | 逻辑内存的一块 | 逻辑地址空间       | 把进程的内存切小块     |
| 页号（Page Number）    | 页的编号       | 逻辑地址空间       | 标识逻辑页             |
| 页框（Frame）          | 物理内存的一块 | 物理地址空间       | 物理页框容纳逻辑页     |
| 页框号（Frame Number） | 页框编号       | 物理地址空间       | 标识物理内存中页框位置 |

分页存储管理中：页框大小 = 页大小

**位图：** 是一个由 `0` 和 `1` 构成的位序列，用来 **标记每个页框是否空闲** ，操作系统通过它来分配或回收页框。每个位对应一个页框，`0` 表示空闲，`1` 已分配。

## 4.2 页表

### 4.2.1 基本概念

- **物理内存**：存放 **页表** 。
- **PCB**：存放页表的 **起始地址** 和 **页表长度** ，进程可以用来在内存中找到自己的页表。每个进程都有自己的页表。

页表是 **操作系统为每个进程维护的数据结构** ，存放在物理内存中（不一定在进程自己的地址空间中），用来记录 `页号 <-> 页框号` 的映射关系。

![alt text](imgs/页表.png)

### 4.2.2 问题一：页表项占多少个字节

假设某个系统物理内存大小为 $4GB$，页面大小为 $4KB$，则每个页表的页表项至少为多少字节？
$$
4GB = 2^{32}B\ ,\ 4KB = 2^{12}B
$$
$$
内存块大小 = 页面大小 = 4KB = 2^{12}B
$$
$$
内存块（或页面）数量 = \frac{2^{32}B}{2^{12}B/块} = 2^{20}块
$$
- 因此内存块的编号范围是 $0$ ~ $2^{20}-1$ ，一个 **页表项** 至少需要 $20 bit$ 来表示。

- 由于内存的最小单位是 `Byte`，至少用 $3B$ 来表示内存块的编号 $3 × 8bit = 24bit$ （比如是 $2B$ 的话，那么只有 $16bit$，显然无法为 `0x00000H ~ 0xFFFFFH` 这个范围内的所有内存块进行编号）。

- **注意：** 
	- 由于内存对齐和控制位的需求，实际系统中通常使用 4B（或 8B）的页表项，**以便一个页框能恰好容纳整数个页表项**。
	- 若采用**纯页式存储**、**多级页表**，则**各级页表大小不能超过一页（一个页框的大小）**。

> 总之，页表项中存放的是“页框号”，不需要存“逻辑页号”，逻辑页号相当于数组的下标。

### 4.3.3 问题二：页表项结构

假设一台机器有 32 位虚拟地址和 16 位物理地址，若页面大小为 512B，采用单级页表，则页表共有多少个页表项?

```bash
虚拟地址（32 位）：
[ 23位页表项 | 9位页内索引 ]

物理地址（16 位）
[ 7位页框号 | 9位页内索引 ]
```

可以发现，页表项有 $2^{23}$ 个，与物理页框数是无关的。

但是“如果页表项是 23 位的话，对应的逻辑页号范围不是 $0$ ~ $2^{23}-1$ 吗？怎么对应到页框号范围 $0$ ~ $2^{7}-1$ 呢？逻辑页号不是会多出很多部分吗？”。如果有这样的问题话，说明对页表结构有一定误解：

- 页表项（PTE）中用于和**物理页框号**映射的部分只需要 **7 位**（因为有 $2^{7}$ 个页框）
- 但是，整个页表项可能还包含其他信息，比如：
    - 有效位（valid bit）
    - 修改位（dirty bit）
    - 访问位（accessed bit）
    - 缓存控制位等
- 所以，一个页表项的总长度可能是 **大于 7 位**，但这不影响页表项的**数量** 。

> 注意：页表本身也必须存放在物理内存中，通常被分割成多个“页表页”，每个页表页占用一个物理页框。这些页表页的物理地址由上一级页表中的页表项来记录和管理（多级页表）。

### 4.2.4 问题三：如何实现地址转换

![alt text](imgs/实现地址转换.png)

**逻辑地址 A** 对应的 **物理地址** = P 号页面在内存中的起始地址 + 页内偏移量 W

可以利用二进制的特点巧妙计算，即：物理地址 = （页框号，页内偏移量）-> 二进制

原因： **页大小是 `2` 的幂次方** ，所以可以用二进制拆分地址位： **高位是页号，低位是页内偏移** 。拼接时也一样：高位是页框号，低位是偏移量，这样加法和乘法都不用做，只需要拼接二进制位。

> 比如：
> 系统物理内存大小为 $4GB$，即 $2^{32}B$，那么物理地址的范围是：$0$ ~ $2^{32}-1$，刚好需要用 `32` 个二进制位来表示；
> 页面大小为 $4KB$，即 $2^{12}B$，那么页内偏移量范围是：$0$ ~ $2^{12}-1$，刚好需要 `12` 个二进制位表示；
> 可以算出页框数量就是 $2^{20}$ 个，那么页框数量（或者说是页框的编号范围）是：$0$ ~ $2^{20}-1$ ，刚好需要 `20` 个二进制位表示。
> 最后一看，这不就有了：页框数量的二进制位数（ `20` 位） + 页内偏移量范围的二进制位数（ `12` 位） = 物理地址范围的二进制位数（ `32` 位）

> 这部分可以结合计算机组成原理中的 cache 映射那个章节，主存地址的二进制位可以分为 $(主存块号, 块内地址)$ 。

## 4.3 基本地址变换机构

> 在分页式内存管理中，操作系统为每个进程维护一张页表，用于将逻辑地址转换为物理地址。计算机中通常设有 **页表寄存器（PTR 或 PTBR）** ，存放页表的起始物理地址 F 以及页表长度 M。
> 当 **进程未被执行时** ，F 和 M 会保存在其 **进程控制块（PCB）** 中。进程 **被调度运行时** ，操作系统将该进程的页表信息加载到 PTR 中，供地址转换使用。

![alt text](imgs/基本地址变换机构.png)

假设一个逻辑地址 $A$（进程发出的地址），页面大小为 $L$，要通过分页机制转化为物理地址 $E$。求解步骤如下：

1. 计算页号和页内偏移量：$页号p = \lfloor A\ \div \ L\rfloor$ （$\lfloor · \rfloor$ 表示向下取整，因为页号是从 `0` 开始编号的），$页内偏移量W = A\ \% \ L$。
	- 更精确地说：如果页大小 $L=2^{n}$ ，可以用**位运算**高效实现（$A$ 用二进制表示）：
	    - $p=A\ ≫\ n$（右移 n 位）
	    - $w=A\ \% \ 2^{n}$（取低 n 位）
	- 例如：$L=4KB=2^{12}B$ ，则在 32 位地址下：
	    - 页号 = 高 20 位
	    - 偏移 = 低 12 位

$$
逻辑地址A \ = \ 页号p \ × \ 每个页的大小L \ + \ 页内偏移W
$$

> 如果是先学了计算机组成原理中的 cache 映射那个章节，再看这里的话就会很通透。

2. 判断页号是否越界：查询页表寄存器中的页表长度 $M$ ，若 $页号p\ >=\ 页表长度M$ ，则越界；反之继续下一步。
3. 查询页表，找到页表项对应的页框号，也就确定出了页面存放的页框号 $b$ 。
4. 计算物理地址：
$$
物理地址E \ = \ 页框号b \  × \ 每个页框的大小L + \ 页内偏移W
$$

整体逻辑就是：`逻辑地址 A -> 拆分页号/偏移 -> 页表查页框 -> 构造物理地址`。

## 4.4 快表（TLB）

**块表**又称**联想寄存器**，是一种访问速度比内存快很多的**高速缓存（`cache`）**，用来**存放最近访问的页表项的副本** ，可以加快地址变换的速度。

![alt text](imgs/快表.png)

1. 引入快表后，改变的地方：
	- 会先在快表里查询，看看是否存在（命中），如果不存在再去页表里查询；
	- 在页表里查询到后，会把该表项存一份到快表中。

2. 快表依据的是 **局部性** 原理：
	- **空间局部性** ：一旦访问了某个存储单元，在不久后，其附近的存储单元也有可能被访问（因为很多数据在内存中都是连续存放的）。
	- **时间局部性** ：如果执行了程序中的某条指令，那么不久后很有可能再次执行到这条指令（因为程序中存在大量的循环）。

3. 多级页表存储方式中采用 TLB
	- 重要重要重要：在二级页表（或更多级的页表）中，若引入快表机构，则快表中的“页号”是“复合页号”！

如下图所示，一个二级页表存储方式中采用 TLB：

![alt text](03内存管理/imgs/多级页表_TLB.png)

也就是说，若快表命中，则可以直接计算出最终目标的物理地址！无需再查更低级的页表！比如通过页号 `(0, 0)` 能直接映射到 `2` 号内存块。

---

> 例题：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 $1\mu s$，访问一次内存耗时 $100\mu s$。若快表的命中率为 $90\%$，那么访问一个逻辑地址的平均耗时是多少？

在具有快表的分页系统中，访问一个逻辑地址的流程如下：
1. **查找快表（TLB）** ：
   - 如果命中（$90\%$ 概率），直接获取物理地址， **无需访问页表** 。
   - 如果未命中（$10\%$ 概率），需要访问内存中的 **页表** 获取物理地址。
2. **访问内存数据** ：
   - 无论是否命中快表，最终都需要访问内存读取数据。

**情况 1：快表命中（$90\%$）**
1. 访问快表：$1\mu s$ 
2. 访问内存数据：$100\mu s$
$$
总时间 = 1 + 100 = 101\mu s
$$

**情况 2：快表未命中（$10\%$）**
1. 访问快表（未命中）：$1\mu s$
2. 访问内存中的页表：$100\mu s$
3. 访问内存数据：$100\mu s$
$$
总时间 = 1 + 100 + 100 = 201\mu s
$$

**平均访问时间（EAT）**
$$
EAT = (\text{命中率} \times \text{命中时间}) + (\text{未命中率} \times \text{未命中时间})
$$
$$
EAT = 0.9 \times 101 + 0.1 \times 201 = 90.9 + 20.1 = 111 \text{ μs}
$$

**补充：**
有的系统支持 **快表和慢表同时查找** ，如果是这样，平均耗时应该是
$$
(1+100) \times 0.9 + (100+100) \times 0.1 = 110.9us
$$

若未采用快表机制，则访问一个逻辑地址需要 $100+100=200\mu s$ ，显然，引入快表机制后，访问一个逻辑地址的速度快多了。

---

快表（TLB） vs CPU Cache 的对比：

| 对比项 | **快表 TLB**（Translation Lookaside Buffer） | **CPU Cache**（高速缓存） |
|--------|---------------------------------------------|----------------------------|
| **作用** | 缓存 **页表项**（逻辑页号 → 物理页框号） | 缓存 **内存中的数据或指令** |
| **解决的问题** | 加速 **地址变换**（逻辑地址 → 物理地址） | 加速 **数据/指令访问**（减少访存延迟） |
| **内容** | 存的是 **页号 → 页框号** 的映射关系 | 存的是 **内存块中的实际数据或代码** |
| **访问时机** | 每次逻辑地址转换时都要查（MMU 自动查） | CPU 读写数据或取指令时查 |
| **位于** | MMU 内部，属于内存管理单元的一部分 | CPU 芯片内部（L1/L2/L3 Cache） |
| **缓存对象** | **页表项**（元数据） | **程序数据和指令**（真实内容） |
| **命中后做什么** | 得到页框号，继续构造物理地址 | 直接使用数据，无需访问内存 |
| **未命中后果** | 访问内存中的页表（一次内存读） | 访问主存（或下一级 cache） |
| **依据的局部性** | 时间局部性 + 空间局部性（程序倾向于重复访问相同页） | 时间局部性 + 空间局部性（程序访问连续内存） |

> 简而言之：**TLB 缓存的是地址映射关系，Cache 缓存的是内容（指令或数据）**。

## 4.5 两级页表

单级页表存在的问题：有时页表的 **长度可能会很大** ，同时页号隐含导致页表必须在内存中连续存放。而根据 **局部性** 原理，很多时候，一段时间内 **只需要访问几个页面** 就可以正常运行，没必要让整个页表常驻内存。但是单级页表会让整个页表常驻内存。

简单来说：两级页表就是把原本一个大页表，拆成两个层次的页表结构，以减少内存空间的浪费。

**优点：** 不需要一次性为每个进程分配完整的页表，只分配实际用到的部分；未访问的部分不创建，懒加载，节省内存。

**两级页表的原理 & 地址结构：**

![alt text](imgs/两级页表的原理和地址结构.png)

逻辑地址 = [一级页号][二级页号][页内偏移]
1. **第一级页表（页目录）** 的每个表项存放的是 **第二级页表的起始物理地址**（即页表基址）；
2. **第二级页表（页表）** 的每个表项存放的是 **物理页框号**；
3. 结合页内偏移，构造出最终的物理地址。

> 两级页表的结构（以 `32` 位虚拟地址为例），假设页面大小 `4KB`（页偏移 = `12` 位），余下 `20` 位用于页号，划分成两部分：
> - 高 `10` 位：页目录索引（Page Directory Index）
> - 中 `10` 位：页表索引（Page Table Index）
> - 低 `12` 位：页内偏移（Page Offset）

```bash
虚拟地址（32 位）：
[ 10位目录索引 | 10位页表索引 | 12位偏移 ]
```

可以在表项中增加一个标志位，可用来表示该页/页表是否在内存中（不存在就触发 **缺页中断** ）：

![alt text](imgs/表项中增加一个标志位.png)

一级页表如何管理二级页表：

```
假设虚拟地址：
[ 7位目录索引 | 9位页表索引 | 16位偏移 ]

二级页表结构：

┌─────────────┐
│  页目录（一级页表）   │ ← 共 128 项
└─────────────┘
     ↓ 每一项指向一个二级页表
     ├──→ 二级页表 0 → 可管理 512 个页（页号 0~511）
     ├──→ 二级页表 1 → 可管理 512 个页（页号 512~1023）
     ├──→ 二级页表 2 → 可管理 512 个页
     ...
     └──→ 二级页表 127 → 可管理 512 个页（最后一批）

每个二级页表占 1 页（2^10 B），存 512 个页表项（每项 2B）
```

从上面可以看出，一级页表管理着 128 项二级页表，一项二级页表管理着 512 个页。

> 注：一级页表也叫做“页目录表”！

基址寄存器中存放的是一级页表的起始物理地址，设为 $\text{A}$ ，假设一级页表的页表项（也就是页目录号）和二级页表的页表项占 $4B$ ，物理地址和虚拟地址均占 32 位，其中虚拟地址划分如下：

| 页目录号（10 位） | 页号（10 位） | 页内偏移量（12 位） |
|-------------------|---------------|---------------------|

那么页目录项的物理地址为：
$$
\text{页目录项地址}\ =\ \text{A} + 4 \times \text{页目录项号} 
$$
页目录项中存放的是**页框号**，即二级页表的起始物理地址。示例如下：

假设这是一级页表存放的内容：

| 页目录号 | 页框号 |
|----------|--------|
| 000H | ... |
| 001H | ... |
| ... | ... |
| 042H | 00301H |
| 000H | ... |

页目录号 `042H` 指向的二级页表如下：

| 页号 | 页框号 |
|----------|--------|
| 000H | ... |
| 001H | ... |
| ... | ... |
| ... | ... |

说明 `042H` 指向的二级页表的起始物理地址为 `00301 000H` 。

---

# 5.基本分段存储管理

分页存储管理虽然能有效管理物理内存，但由于其**固定大小的页面划分方式**，将程序的逻辑地址空间**机械分割**，导致：
- 程序的逻辑模块（如代码、数据）可能被拆分到多个页面中；
- 难以实现**按逻辑单位的共享与保护**；
- 不便于程序员或操作系统对内存进行语义化管理。 

因此，引入**分段管理**，以更好地支持信息共享、内存保护和程序结构的自然表达。

**分段管理**：把 **程序的逻辑地址空间** 划分成若干 **“逻辑段”** ，每个段代表程序的一部分，比如：代码段、数据段、堆栈段等。

举个例子，一个程序的逻辑分段如下表所示：

| 段名   | 功能         |
| ------ | ------------ |
| 代码段 | 存放指令     |
| 数据段 | 存放全局变量 |
| 堆段   | 动态内存     |
| 栈段   | 函数调用栈   |

## 5.1 分段管理概念

- **概念**：按照程序的自身逻辑关系划分为若干个段，每个段都有一个段名，每段从 `0` 开始编址。
- **内存分配规则**：以**段**为单位进行分配，每个段在内存中占据连续空间（**段内连续**），但**各段之间可以不相邻** 。

![alt text](imgs/分段管理.png)

分段系统的逻辑地址结构  = [段号] + [段内偏移]
> 比如：段号 = `2`，偏移 = `0x00000400H`，意思是访问第 `2` 段中偏移 `1024` 的位置。

![alt text](imgs/分段系统的逻辑地址结构.png)

## 5.2 段表

- 每个段都对应一个段表项，其中记录了该段在内存中的 **起始位置** （基址）和 **段的长度** 。
- 各个 **段表项的长度都是相同的** ，段号可以隐含，不占存储空间。

![alt text](imgs/段表.png)

段式分配中的访存方式：

![alt text](imgs/段式访存.png)

段表和页表的区别：

| 对比项       | 段表（Segment Table）                      | 页表（Page Table）                         |
| ------------ | ------------------------------------------ | ------------------------------------------ |
| 用于哪种管理 | 分段管理（Segmentation）                   | 分页管理（Paging）                         |
| 地址结构     | 段号 + 段内偏移                            | 页号 + 页内偏移                            |
| 表的作用     | 查找段的起始物理地址 + 检查段界限          | 查找页的物理页框地址                       |
| 每项内容     | Base（基址） + Limit（长度）               | Frame Number（页框号）+ 标志位（如存在位） |
| 每项代表     | 一个**逻辑模块（段）**，如代码段、数据段等 | 一个**固定大小的页面**                     |
| 段/页大小    | 每段大小 **可以不一样** ，灵活             | 每页大小 **相同** ，比如固定`4KB`          |
| 是否检查越界 | ✅ 是的（因为各段大小不固定）               | ❌ 不检查，偏移总在页内                     |
| 碎片问题     | 可能有**外部碎片**                         | 可能有**内部碎片**（最后一页可能不满）     |

## 5.3 地址变化

![alt text](imgs/段式存储-地址变化.png)

## 5.4 补充

> 有时候，我们在运行通过 C/C++ 写的程序时，会出现 `Segmentation fault` 这种类似的错误，表示 **段错误** ，正好就跟我们这里学的内存分段管理、段表机制有很直接的关系。

`Segmentation fault` 是程序运行时访问了不该访问的内存段，导致操作系统终止了程序。它通常表示：“你访问的内存地址不在你程序的合法段范围内！”

🔍 跟分段管理有什么关系？

这就要从**段表的 Limit（段界限）检查机制**说起了。在**分段系统**中，每次访问内存时，CPU 都会这么做：

```bash
物理地址 = 段表[段号].Base + 段内偏移
```

但**在访问前**，它会先判断：

```cpp
if (段内偏移 > 段表[段号].Limit) {
    报错：Segmentation fault!
}
```

所以，程序访问了一个不在段内的地址 ⇒ 非法 ⇒ 操作系统发现越界 ⇒ 直接杀掉程序，最后给你一个提示：“Segmentation fault”。

造成这种现象的原因有很多，常见的有：访问空指针、访问已经删除的内存、数组越界、栈溢出（函数递归过深）。知道原因后，也为我们调试代码提供了一定思路。

# 6.段页式存储管理

## 6.1 段氏和页式的优缺点

1. 分页式存储：

| 优点               | 说明                         |
| ------------------ | ---------------------------- |
| ✅ 避免**外部碎片** | 所有页大小相同，内存利用率高 |
| ✅ 内存管理简单     | 固定大小，分配容易           |
| ✅ 易于实现虚拟内存 | 不连续的页也能映射           |

| 缺点                  | 说明                                   |
| --------------------- | -------------------------------------- |
| ❌ 可能有 **内部碎片** | 页内用不完的空间浪费掉（比如最后一页） |
| ❌ 程序结构不清晰      | 按大小分，不考虑逻辑结构               |
| ❌ 无法支持段级权限    | 不能对“函数段只读”、“栈段可写”做区分   |

2. 分段式存储：

| 优点                 | 说明                                           |
| -------------------- | ---------------------------------------------- |
| ✅ 更贴合程序逻辑结构 | 段代表代码段、数据段、堆、栈等                 |
| ✅ 支持权限/共享控制  | 每段可设置“只读/可写”、“是否共享”              |
| ✅ 编程更自然         | 程序员直接看到段的语义结构（比如变量在数据段） |

| 缺点                     | 说明                                                 |
| ------------------------ | ---------------------------------------------------- |
| ❌ 容易产生 **外部碎片**  | 段大小不固定，内存容易被“夹碎”                       |
| ❌ 内存管理复杂           | 段长不等，分配、合并都麻烦                           |
| ❌ 不适合现代虚拟内存机制 | 虚拟内存需要均匀分页映射，分段不方便页置换等策略实现 |

简而言之：
> 📗 分页追求“**管理效率**”，统一块大小，牺牲语义。
> 📘 分段追求“**结构语义**”，符合程序逻辑，管理难度大。

## 6.2 段页式管理概念

定义：先将程序按逻辑划分为段（如代码段、数据段等），然后 **每段内部再分页** ，这样结合了“分段的逻辑性”和“分页的内存效率”，也就是 **逻辑上用分段，物理上用分页** 。

![alt text](imgs/段页式.png)

段页式系统的逻辑地址结构由 **段号** 、 **页号** 、 **页内地址（页内偏移量）** 组成。如：

![alt text](imgs/段页式-逻辑结构地址.png)

每个段对应一个段表项，每个段表项由 **段号、页表长度、页表存放块号（页表起始地址）** 组成；每个 **段表项长度相等** ，段号是隐含的。其中每个页面又对应一个页表项，每个页表项由 **页号、页面存放的内存块号** 组成；每个 **页表项长度相等** ，页号是隐含的。

![alt text](imgs/段页式访问示意图.png)

## 6.3 地址变化

![alt text](imgs/段页式地址变化.png)
