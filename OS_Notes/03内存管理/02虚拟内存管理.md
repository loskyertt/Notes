# 1.早期内存空间的扩充技术

## 1.1 覆盖技术

覆盖技术用来解决程序大小超过物理内存总和问题（比如一个几十多 GB 的游戏要放到只有 4GB 的内存上运行）。

**思想：** 将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为 **一个固定区** 和 **若干个覆盖区** 。把要 **常驻内存段放在固定区** ，调入后就不再调出（除非运行结束）； **不常用的段放在覆盖区** ，需要用到时调入内存，用不到时调出内存。

如下图所示，其中 A 一直运行，A 会调用 B 或 C（不会同时调用），B 会调用 D，C 会调用 E 或 F（不会同时调用）。可知 B、C 不可能同时进入内存，D、E、F 不可能同时进入内存，所以开辟两个覆盖区即可（节约内存）。

![alt text](imgs/覆盖技术.png)

**缺点：** 必须由程序员声明覆盖结构，操作系统完成自动覆盖；对用户不透明，增加了用户编程负担。

## 1.2 交换技术

**思想：** 内存空间紧张时，系统将内存中某些进程暂时 **换出外存（挂起）** ，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）。

**三个问题：**

1. 被换出的进程应该保存在外存（磁盘）的什么位置？
   - 磁盘存储空间分为 **对换区** & **文件区**；
   - 文件区：采用离散分配方式，存放文件（主要追求磁盘空间的利用率）；
   - 对换区：采用连续分配方式，存放换出进程的数据（主要追求换出换入速度）；
   - 对换区的 I/O 速度比文件区更快（连续块减少寻道时间，尽管远小于内存）。

1. 什么时候应该换出？
	- 可用内存低于某个阈值（如“页回收阈值”）；
	- 内核的 **kswapd** 守护进程持续监控内存状态，在内存紧张时启动页回收；
	- 页面分配失败且无法通过释放缓存（如 page cache）缓解时，开始换出匿名页（即进程数据）。

3. 应该换出哪些进程？
   - 优先换出 **阻塞** 进程；
   - 优先换出 **优先级低** 的进程；
   - 长时间未被访问的页面（或进程）更可能被淘汰（类似 LRU 思想）。

> 注意：PCB（进程控制块）保存了进程的核心信息：进程状态、寄存器值、内存映射、I/O状态等，操作系统必须随时访问，因此**不能被换出** 。换出的通常是**进程映像的用户空间部分**，包括代码段、数据段、堆栈等。

---

# 2.虚拟存储技术

传统存储管理方式的特征和缺点：

1. **一次性**：作业必须一次性全部装入内存后才能开始运行
   - 作业很大时，不能全部装入内存，导致大作业无法运行；
   - 当大量作业要求运行时，由于内存无法容纳所有的作业，因此只有少量作业能运行，导致多道程序 **并发度下降** 。

1. **驻留性**：一旦作业被装入内存，就会一直驻留内存中，直至作业运行结束
   - 事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行。

## 2.1 虚拟内存的定义和特征

- 基于局部性原理，在程序装入时，可以将程序中很快用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。
- 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需要的信息从外存调入内存，然后继续执行程序。
- 若内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存。

简而言之，在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。

**虚拟内存的特点**：
- **多次性**：无需在作业运行时一次性全部装入内存，而是运行被分为多次调入内存。
- **对换性**：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
- **虚拟性**：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际容量。

$$
\text{实际虚拟内存大小} = min\{内存+外存容量, CPU 寻址范围\}
$$

$$
\text{虚拟内存最大容量} = CPU 寻址范围
$$

## 2.2 实现虚拟内存技术

在传统的非连续分配存储管理的方式下进行改进：请求分页存储管理、请求分段存储管理、请求段页式存储管理。

**主要区别：**
在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需要信息从外存调入内存，然后继续执行程序。步骤如下：
1. 页（或段）不在内存 → 缺页（或缺段） **中断**
2. 操作系统从磁盘中将所需页/段调入内存
3. 修改页表/段表，重新执行指令

若内存空间不够，由操作系统根据页面置换算法负责将内存中暂时用不到的信息换出到外存。

---

# 3.请求分页管理方式

## 3.1 页表机制

新增**两个**功能：
- **请求调页**：操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。
- **页面置换**：操作系统需要通过某些指标来决定到底换出哪个页面（需要记录页面是否被修改）。

添加了四个标志位：

| 标志位       | 含义与作用                                                                      |
| ------------ | ------------------------------------------------------------------------------- |
| **状态位**   | 也称“ **驻留位（Present bit）** ”，表示该页是否已经在内存中（`1` 在，`0` 不在） |
| **访问字段** | 记录该页的访问情况（访问次数/最近访问时间）用于页面置换算法                     |
| **修改位**   | 也称“ **脏页位（Dirty bit）** ”，若页面被写过则置为 `1` ，换出时必须写回磁盘    |
| **外存地址** | 页面未调入时，操作系统需要根据此字段定位该页在磁盘中的位置（如 `swap` 区偏移）  |

![alt text](imgs/请求分页管理方式-页表机制.png)

## 3.2 缺页中断机构

在请求分页系统中，每当要访问的页面不在内存时，便产生一个 **缺页中断** ，然后由操作系统的 **缺页中断处理程序** 处理中断。

> 这也说明“缺页中断”是一个内中断（即“异常”），且是其中的“故障”。回忆下中断的分类......

此时缺页的进程 **阻塞** ，放入阻塞队列，调页完成后再将其唤醒，放回 **就绪** 队列：
- 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项；
- 如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。

## 3.3 地址变换机构

- 只有 **写指令** 才需要修改 **修改位** 。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表，这样可以减少访存次数（其实和 Cache 的“回写法”一个意思）。
- 和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场。
- 需要用某种 **页面置换算法** 来决定一个换出页面。
- 换入/换出页面都需要启动慢速的 I/O 操作，可见，如果换入/换出太频繁，会有很大的开销。
- 页面调入内存后，需要 **修改慢表** ，同时也需要将表项复制到快表中。

![alt text](imgs/请求分页管理方式-地址变换机构.png)

---

# 4.页面置换算法

## 4.1 最佳置换算法（OPT）

每次选择淘汰的页面将是 **以后永不使用** ，或者在 **最长时间内不再被使用访问** 的页面。

![alt text](imgs/页面置换算法-OPT.png)

> 注：上图中打勾的表示 **缺页中断** 。从第 `4` 个页面开始才会发生页面置换，因为内存块不够了嘛。

最佳置换算法可以保证 **最低的缺页率** ，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面，操作系统无法提前预判页面访问序列。因此，最佳置换算法是 **无法实现** 的。

## 4.2 先进先出置换算法（FIFO）

每次选择淘汰的页面是 **最早进入内存** 的页面。

**实现方法：** 把调入内存的页面根据调入的 **先后顺序** 排成一个 **队列** ，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。

![alt text](imgs/页面置换算法-FIFO.png)

**Belady 异常：** 当为进程分配的内存块增大时，出现缺页次数不减反增的异常现象（可以假设当内存块增大为四个时，会有多少次缺页次数）。

只有**FIFO 算法**会**可能**产生**Belady 异常**。另外，FIFO 算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问，因此，算法性能差。

## 4.3 最近最久未使用置换算法（LRU）

每次淘汰的页面是 **最近最久未使用** 的页面。

**实现方法：** 赋予每个页面对应的页表项中，用访问字段记录该页面 **上次被访问以来所经历的时间 `t` ** 。当需要淘汰一个页面时，选择现有页面中 **`t` 值最大** 的，即最近最久未使用的页面。

![alt text](imgs/页面置换算法-LRU.png)

该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。

> **补充**：对于平时做题（手算）来说，可以这样思考，以从左往右数第 `11` 个页面为例（页面号是 `3`），这时需要进行页面置换，我们只需要“从右往左数数字”，即 `8 -> 1 -> 2 -> 7`，发现 `7` 是最久没有被访问过的，就把 `7` 号页面替换了。

## 4.4 时钟置换算法（CLOCK）

时钟置换算法是一种 **性能和开销较均衡** 的算法，又称 **CLOCK 算法** （检查页面的时候，像时钟一样转圈）。**CLOCK 算法** 是一种近似 **LRU** 的算法，与 **最近未使用算法（NRU）** 都基于 **最近使用情况** 来决策页面替换，但实现方法不同。

**实现方法**：
1. 为每个页面设置一个 **访问位** ，将内存中页面都通过指针链接形成一个 **循环队列** ；
2. 当某页面被访问时，将其访问位置为 `1`；
3. 当需要淘汰一个页面时，只需检查页面的访问位：
   - 如果访问位是 `0`，则选择 **换出** ；
   - 如果访问位是 `1`，则将它置为 `0`，暂不换出，继续检查下一个页面；
1. 如果第一轮扫描没有符合条件的页面，则继续扫描第二轮（第二轮一定有访问位为 `0` 的页面）。

所以该算法 **最多扫描两轮** 。

> 操作实现可以记为**一转为 `1` 改访问，再转为 `0` 就送走**。

## 4.5 改进型时钟置换算法

简单的时钟置换算法仅仅考虑了是否被访问过，如果一个页面访问过但是未被修改，淘汰时就不需要写回内存，应该优先淘汰此类的页面，可以减少 I/O 操作写回内存。

用 **两个** 标志位（ **访问位** ， **修改位** ）来记录一个页面是否被访问过，是否被修改过。在其它条件都相同的时候，应该 **优先淘汰没有修改过的页面** ，避免 I/O 操作。

**实现方法**：
将所有可能被置换的页面排成一个 **循环队列** ；
1. 第一轮：从当前位置开始扫描到第一个（0，0）的页面用于替换。本轮扫描 **不修改任何标志位**。

> 第一优先级：最近没访问，且没修改的页面。

2. 第二轮：若第一轮扫描失败，则重新扫描，查找 **第一个（0，1）的页面** 用于替换。本轮所有扫描过的页面 **访问位设置为 `0`**。

> 第二优先级：最近没访问，但修改过的页面。

3. 第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的页面用于替换。本轮扫描 **不修改任何标志位**。

> 第三优先级：最近访问过，但没修改的页面。


4. 第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的页面用于替换。

> 第四优先级：最近访问过，且修改过的页面。

所以该算法 **最多扫描四轮** 。

## 4.6 对比

| 算法           | 实现方式                           | 优点                        | 缺点                               | 性能 |
| -------------- | ---------------------------------- | --------------------------- | ---------------------------------- | ---- |
| **OPT**        | 优先淘汰最长时间内不会被访问的页面 | 最优性能，最小化缺失率      | 不可实现，依赖未来访问模式         | 最优 |
| **FIFO**       | 优先淘汰最先进入内存的页面         | 实现简单，易理解            | 忽略访问模式，可能替换频繁访问页面 | 差   |
| **LRU**        | 优先淘汰最近最久未访问的页面       | 优化访问局部性，较少缺失    | 需要硬件支持，实现复杂，更新开销大 | 较好 |
| **CLOCK**      | 优先淘汰最近未访问的页面           | 实现简单，比 LRU 更节省内存 | 近似 LRU，性能较差                 | 中等 |
| **改进型时钟** | 优先淘汰最近未访问且未修改的页面   | 减少磁盘 I/O，优化性能      | 实现复杂，内存开销较大             | 好   |

---

# 5.页面分配与置换策略

1. **驻留集**：是指在请求分页系统中，**当前驻留在物理内存中的进程页面集合**。
	- 在虚拟内存系统中，驻留集大小通常远小于进程的总大小；
		- 若驻留集 **过小**，会导致频繁缺页，引发 **抖动（Thrashing）** 现象，系统大部分时间用于页面换入换出，CPU 利用率急剧下降；
		- 若驻留集 **过大**，单个进程占用过多内存，导致其他进程无法获得足够内存资源，**多道程序并发度下降**，系统整体效率降低。

2. **分配策略**：
	- **固定分配**：操作系统为每个进程分配固定数量的物理块，运行期间驻留集大小不变。缺页时只能进行局部置换。
	- **可变分配**：操作系统初始为进程分配一定数量物理块，运行期间可根据缺页情况动态增减其驻留集大小。

3. **置换策略**：
	- **局部置换**：发生缺页时，只能从**该进程自身拥有的物理页框**中选择页面进行置换。
	- **全局置换**：所有进程的页面都参与置换决策。当某进程缺页时，可以选择换出**系统中任意一个可换出的页面**（包括其他进程的页面），从而将释放的页框分配给缺页进程。

![alt text](imgs/固定分配与可变分配.png)

## 5.1 分配策略与置换策略的组合

1. **固定分配 + 局部置换**
	- 每个进程在创建时被分配固定数量的物理页框，运行期间保持不变；
	- 缺页时只能从**该进程自身的驻留集中选择页面换出**；
	- 初始分配需根据进程大小、优先级等预估，但难以精确；
	- 实现简单，进程间互不干扰，但是易导致缺页率过高或内存浪费。

2. **可变分配 + 全局置换**
	- 缺页时，系统优先从**空闲页框链表**中分配新页；
	- 若无空闲页，则从**系统中任意可换出的页面**（包括其他进程的页面）中选择牺牲页进行置换；
	- 该策略下，一个进程的缺页行为可能间接导致其他进程页面被换出，造成性能波动；
	- 是现代操作系统（如 Linux）常用的策略，具有高内存利用率，但存在进程间干扰风险。

3. **可变分配 + 局部置换**
	- 缺页时仅允许置换本进程的页面；
	- 系统根据**缺页率趋势**动态调整进程的物理块数量：
	    - 缺页率高 → 增加分配；
	    - 缺页率低 → 减少分配；
	- 此策略是 **工作集模型** 和 **抖动预防机制** 的理论基础，兼顾动态性和隔离性。

页面管理策略的三种典型组合对比：

| 页面分配方式 | 页面置换方式 | 策略特点                                       |
| ------------ | ------------ | ---------------------------------------------- |
| 固定分配     | 局部置换     | 简单，静态，进程间互不干扰，但分配难以合理估计 |
| 可变分配     | 全局置换     | 动态调配，内存利用率高，但可能引发进程间干扰   |
| 可变分配     | 局部置换     | 动态调配，进程独立性好，适用于工作集模型       |

## 5.3 工作集和工作集窗口

- **工作集**：是指一个进程在最近一段时间内实际访问过的**页面集合**，反映了其当前活跃的内存需求。随着程序执行，工作集会动态变化。

- **工作集窗口**：是一个**基于页面访问序列的滑动窗口**，大小为 $\Delta$，表示考察最近 $\Delta$ 次页面访问所涉及的页面。

设 $W(t,\ \Delta)$ 表示在时刻 $t$ 、窗口大小为 $\Delta$ 的工作集。

示例：

若工作集窗口大小 $\Delta=6$ ，最近 6 次页面访问序列为：`6, 0, 3, 2, 3, 2`，则工作集为这些页面的去重集合：
$$
W(t,\ 6)\ =\ \{6,0,3,2\}
$$
该集合表示进程当前最可能继续访问的页面，系统应尽量将其保留在内存中，以避免频繁缺页。